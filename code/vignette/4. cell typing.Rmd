---
title: "Cell typing"
output: 
rmarkdown::html_vignette: 
fig_width: 7 
fig_height: 8 
vignette: >
  %\VignetteIndexEntry{Cell typing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
<style>
p.caption {
  font-size: 1.5em;
}
</style>
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Introduction

Cell typing is a crucial stage of analysis requiring careful attention. 
To ensure the integrity of your analyses, you must spend time reviewing, and possibly refining, your cell typing results.

Here we'll demonstrate a basic cell typing workflow using the Insitutype algorithm. 
We'll show the core QC plots and walk through examples of how you can refine your cell typing results. 

For more details on cell typing, see these resources:

- [Short review of cell typing algorithms](https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/blob/Main/blog/cell%20typing%20basics.md)
- [Insitutype FAQs](https://github.com/Nanostring-Biostats/InSituType/blob/main/FAQs.md)
- [Insitutype vignettes](https://github.com/Nanostring-Biostats/InSituType/tree/main/vignettes)
- [Insitutype preprint](https://www.biorxiv.org/content/10.1101/2022.10.19.512902v1)


## Cell typing preparation

Our example dataset is from human kidneys. Fortunately for us, previous investigators 
have already run single cell experiments in kidneys and done the hard work of defining which
cell types are present. 
We could repeat their work and cluster our data de novo, but the easiest approach is to
classify our cells based on this previous work. 
The Insitutype algorithm compares cells' expression profiles to "reference profiles"
derived from earlier datasets. We can easily derive these from our favorite single cell dataset,
or even easier, pull one from resources NanoString has compiled:

- [Cell profiles derived from scRNA-seq](https://github.com/Nanostring-Biostats/cellprofilelibrary)
- [Cell profiles derived from CosMx](https://github.com/Nanostring-Biostats/CosMx-Cell-Profiles)

The CosMx-derived profiles should be preferred when available, as they escape the 
strong platform effects found between CosMx and scRNA-seq. 
For now, the library of scRNA-seq profiles covers more tissue types.

We'll download a reference profile from a previous CosMx experiment:

```{r getreference}
# load CosMx data:
mydir <- "//nanostring.local/RND/analysis-files/pdanaher/vignette/"
metadata <- readRDS(paste0(mydir, "/processed_data/metadata.RDS")) 
counts <- readRDS(paste0(mydir, "/processed_data/counts.RDS")) 
negcounts <- readRDS(paste0(mydir, "/processed_data/negcounts.RDS")) 
um <- readRDS(paste0(mydir, "/processed_data/um.RDS"))
xy <- readRDS(paste0(mydir, "/processed_data/xy.RDS"))


#refprofiles <- read.csv("https://github.com/Nanostring-Biostats/CosMx-Cell-Profiles/Human/Kidney/Kidney.profiles.csv", row.names = 1, header = TRUE)
mydir <- "//nanostring.local/RND/analysis-files/pdanaher/vignette/"
#refprofiles <- as.matrix(read.csv(paste0(mydir, "/data/Kidney.profiles.csv"), row.names = 1, header = TRUE))
refprofiles <- readRDS(paste0(mydir, "/data/Lake et al profiles.RDS"))
refprofiles[1:5,1:5]
dim(refprofiles)
refprofiles <- refprofiles[is.element(rownames(refprofiles), colnames(counts)), ]
pheatmap::pheatmap(sweep(refprofiles, 1, pmax(apply(refprofiles, 1, max), 0.2), "/"), 
                   col = colorRampPalette(c("white", "darkblue"))(100))

```

## Initial cell typing 

Next we'll use Insitutype to assign our cells to these previously-published cell types:

```{r runinsitutype}
library(InSituType)
insitutypefileloc <- paste0(mydir, "/processed_data/insitutype_initial_results.RDS")
if (!file.exists(insitutypefileloc)) {
  res <- InSituType::insitutype(x = counts, 
                              neg = Matrix::rowMeans(negcounts), 
                              reference_profiles = refprofiles,
                              update_reference_profiles = FALSE,
                              n_clust = 0,  # don't fit any additional clusters
                              assay_type = "rna")
  saveRDS(res, file = insitutypefileloc)
} else {
  res <- readRDS(insitutypefileloc)
}
```


First we choose cell type colors. Doing this by hand is usually desirable later on. But for now, before we've finalized
our cell typing results, we can just use an automated approach.

```{r choosecolors}
cols <- InSituType::colorCellTypes(freqs = table(res$clust), palette = "brewers")
cols
```

## QC of cell typing results

Now we enter the crucial QC phase. Below we'll print out a variety of QC plots and discuss their interpretation. 
We start with UMAP and "flightpath" plots. Flightpath plots are specific to methods like Insitutype which score every cell's probability of belonging to every cluster. 
They show the tendency of different cell types to be confused with each other. 


```{r qcplots, fig.dim=c(8,8)}
# flightpath
flightpath <- flightpath_layout(logliks = res$logliks, profiles = res$profiles)
par(mar = c(0,0,0,0))
plot(flightpath$cellpos, pch = 16, cex = 0.1, col = cols[res$clust])
text(flightpath$clustpos[, 1], flightpath$clustpos[, 2], rownames(flightpath$clustpos), cex = 0.7)
# umap
plot(um, pch = 16, cex = 0.1, col = cols[res$clust])
for (cell in unique(res$clust)) {
  text(median(um[res$clust == cell, 1]), median(um[res$clust == cell, 2]), cell, cex = 0.7)  
}
# xy space:
plot(xy, pch = 16, cex = 0.5, col = cols[res$clust],
     xlim = c(9.5, 11.5), ylim = c(4, 6))   # zooming in for legibility. The full plot should be printed to a high-res .png.
# print to a png to examine the full xy space:
png(paste0(mydir, "/results/cell_type_map.png"), 
      width = diff(range(xy[,1]))*.7, height = diff(range(xy[,2]))*.7, units = "in", 
      res = 500)  # res of 400 is pretty good; 600 is publication-quality
par(mar = c(0,0,0,0))
plot(xy, pch = 16, col = cols[res$clust], cex = 0.1,
     xlab = "", ylab = "", xaxt = "n", yaxt = "n", asp = 1)
legend("topright", pch = 16, col = cols, legend = names(cols), cex = 0.5)
dev.off()
```

Higher rates of confusion are seen between closely-related cell types, e.g. Distinct proximal tubule types A and B. 
But for the most part this is a good result, with no indication that any clusters are irredeemably confused. 

Next we draw a heatmap of the cluster profiles. These are helpful for confirming that clusters have the expected marker genes,
or for understanding what cell types unknown clusters are. It's often useful to print out a very long pdf of this heatmap in
which every gene name is visible. 

```{r heatmap}
# profiles heatmap
#pdf(paste0(mydir, "/results/celltypeprofiles.pdf"), height = 20)
pheatmap::pheatmap(sweep(res$profiles, 1, pmax(apply(res$profiles, 1, max), 0.2), "/")[apply(res$profiles, 1, max) > 0.2, ],  
                   fontsize_row = 4,
                   col = colorRampPalette(c("white", "darkblue"))(100))  
#dev.off()
# (the use of pmax(..., 0.2) prevents genes with very low signal in all cell types from appearing exciting)
```

And finally, we'll want to see every cell type's spatial spread. You generally need a pretty 
big plot to actually resolve details, so you'll want to print the plot to a .png.
(Don't use vector graphics like pdf or svg - they save the location of every cell and so turn into huge files.)
Code like the below is good for this:

```{r spatialplots, eval = FALSE}
for (cell in unique(res$clust)) {
  png(paste0(mydir, "/results/celltypev1_", cell, ".png"), 
      width = diff(range(xy[,1]))*.7, height = diff(range(xy[,2]))*.7, units = "in", 
      res = 400)  # res of 400 is pretty good; 600 is publication-quality
  par(mar = c(0,0,0,0))
  plot(xy, pch = 16, col = "grey80", cex = 0.1,
       xlab = "", ylab = "", xaxt = "n", yaxt = "n")
  points(xy[res$clest == cell, ], pch = 16, cex = 0.2, col = cols[cell])
  legend("top", legend = cell)
  dev.off()
}
```

## Refining cell type results

Cell typing deserves careful attention: it's a complex process, and your entire analysis depends on its results. 
Scrutinize the above QC plots for suspicious patterns. These could be:

- Unlikely spatial distributions
- Unlikely cell type abundances, e.g. a far too many immune cells, or not enough of a basic cell type (proximal tubules in our sample)
- Implausible marker genes expressed at high levels
- Biologically dissimilar cell types with similar expression profiles (near each other in UMAP space, confused with each other in the flightpath, showing similar profiles in the heatmap.)

For a deep dive on this topic, see the [Insitutype FAQs](https://github.com/Nanostring-Biostats/InSituType/blob/main/FAQs.md).

Below is an example of how to refine cell typing results. 
We use Insitutype's built-in function "refineClusters".

Here we see that the Neutrophil cluster has overrun the tissue. Since we expect vanishingly few neutrophils here,
we'll delete this cluster and reassign its cells to their next-best fit.
We'll also merge the two T-cell clusters for simplicity, and we'll subcluster podocytes to 
see if any variability exists.

```{r refineclusters}
refinedfileloc <- paste0(mydir, "/processed_data/insitutype_refined_results.RDS")
if (!file.exists(refinedfileloc)) {
    res2 <- refineClusters(logliks = res$logliks, 
                           counts = counts,
                           neg = Matrix::rowMeans(negcounts), 
                           merges = c("T.cell.CD4" = "T-cell",
                                      "T.cell.CD8" = "T-cell"),      # merge CD4 and CD8 cells to a broader "T-cell" category
                          to_delete = "Neutrophil",                  # delete this cluster and send its cells to their next-best fit
                          subcluster = list("Podocyte" = 2))         # subcluster podocytes into 2 new clusters
  saveRDS(res2, file = refinedfileloc)
} else {
  res2 <- readRDS(refinedfileloc)
}

str(res2)   # same structure as the Insitutype output, but with new cell types
```

After running refineClusters, you'll want to re-run all the above QC plots.

```{r qc2, eval=TRUE}
# choose colors:
cols2 <- InSituType::colorCellTypes(freqs = table(res2$clust), palette = "brewers")

# heatmap of profiles:
pheatmap::pheatmap(sweep(res2$profiles, 1, pmax(apply(res2$profiles, 1, max), 0.2), "/")[apply(res2$profiles, 1, max) > 0.2, ],  
                   fontsize_row = 4,
                   col = colorRampPalette(c("white", "darkblue"))(100))  

# flightpath:
flightpath2 <- flightpath_layout(logliks = res2$logliks, profiles = res2$profiles)
par(mar = c(0,0,0,0))
plot(flightpath2$cellpos, pch = 16, cex = 0.1, col = cols2[res2$clust])
text(flightpath2$clustpos[, 1], flightpath2$clustpos[, 2], rownames(flightpath2$clustpos), cex = 0.7)

# umap:
plot(um, pch = 16, cex = 0.1, col = cols2[res2$clust])
for (cell in unique(res2$clust)) {
  text(median(um[res2$clust == cell, 1]), median(um[res2$clust == cell, 2]), cell, cex = 0.7)  
}

# xy space:
plot(xy, pch = 16, cex = 0.5, col = cols2[res2$clust],
     xlim = c(9.5, 11.5), ylim = c(4, 6))   # zooming in for legibility. The full plot should be printed to a high-res .png.


# xy plots:
for (cell in unique(res$clust)) {
  png(paste0(mydir, "/results/celltypev1_", cell, ".png"), 
      width = diff(range(xy[,1]))*.7, height = diff(range(xy[,2]))*.7, units = "in", 
      res = 400)  # res of 400 to limit file size; 600 is publication-quality
  par(mar = c(0,0,0,0))
  plot(xy, pch = 16, col = "grey80", cex = 0.1,
       xlab = "", ylab = "", xaxt = "n", yaxt = "n")
  points(xy[res2$clust == cell, ], pch = 16, cex = 0.2, col = cols2[cell])
  legend("top", legend = cell)
  dev.off()
}

```

Finally we'll save our results:

```{r save}
# save the whole insitutype result:
saveRDS(res2, file = paste0(mydir, "/processed_data/insitutype_results.RDS"))

# save the vector of cluster assignments:
saveRDS(res2$clust, file = paste0(mydir, "/processed_data/celltype.RDS"))
```