---
title: "Cell typing"
output: 
rmarkdown::html_vignette: 
toc: true
fig_width: 7 
fig_height: 8 
vignette: >
  %\VignetteIndexEntry{Cell typing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
<style>
p.caption {
  font-size: 1.5em;
}
</style>
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Introduction

Cell typing is a crucial stage of analysis requiring careful attention. 
Automated cell typing algorithms can work as desired out of the box, but often enough they do not. 
So if you care about the integrity of your analyses, you'll spend time reviewing, and possibly refining, your cell typing results.

Here we'll demonstrate a basic cell typing workflow using the Insitutype algorithm. 
We'll show the core QC plots and walk through examples of how you can refine your cell typing results. 

For more details on cell typing, see these resources:

- [Short review of cell typing algorithms](https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/blob/Main/blog/cell%20typing%20basics.md)
- [Insitutype FAQs](https://github.com/Nanostring-Biostats/InSituType/blob/main/FAQs.md)
- [Insitutype vignettes](https://github.com/Nanostring-Biostats/InSituType/tree/main/vignettes)
- [Insitutype preprint](https://www.biorxiv.org/content/10.1101/2022.10.19.512902v1)


## Cell typing preparation

Our example dataset is from human kidneys. Fortunately for us, previous investigators 
have already run single cell experiments in kidneys and done the hard work of defining which
cell types are present. 
We could repeat their work and cluster our data de novo, but the easiest approach is to
classify our cells based on this previous work. 
The Insitutype algorithm compares cell's expression profiles to "reference profiles"
derived from earlier datasets. We can easily derive these from our favorite single cell dataset,
or even easier, pull one from resources NanoString has compiled:

- [Cell profiles derived from scRNA-seq](https://github.com/Nanostring-Biostats/cellprofilelibrary)
- [Cell profiles derived from CosMx](https://github.com/Nanostring-Biostats/CosMx-Cell-Profiles)

The CosMx-derived profiles should be preferred when available, as they escape the 
strong platform effects found between CosMx and scRNA-seq. 
For now, the library of scRNA-seq profiles covers more tissue types.

We'll download a reference profile from a previous CosMx experiment:

```{r getreference}
# load CosMx data:
mydir <- "//nanostring.local/RND/analysis-files/pdanaher/vignette/"
metadata <- readRDS(paste0(mydir, "/processed_data/metadata.RDS")) 
counts <- readRDS(paste0(mydir, "/processed_data/counts.RDS")) 
negcounts <- readRDS(paste0(mydir, "/processed_data/negcounts.RDS")) 
xy <- readRDS(paste0(mydir, "/processed_data/xy.RDS"))


#refprofiles <- read.csv("https://github.com/Nanostring-Biostats/CosMx-Cell-Profiles/Human/Kidney/Kidney.profiles.csv", row.names = 1, header = TRUE)
mydir <- "//nanostring.local/RND/analysis-files/pdanaher/vignette/"
refprofiles <- as.matrix(read.csv(paste0(mydir, "/data/Kidney.profiles.csv"), row.names = 1, header = TRUE))
pheatmap::pheatmap(sweep(refprofiles, 1, pmax(apply(refprofiles, 1, max), 0.2), "/"), 
                   col = colorRampPalette(c("white", "darkblue"))(100))

```

## Initial cell typing 

Next we'll use Insitutype to assign our cells to these previously-published cell types:

```{r runinsitutype}
library(InSituType)
res <- InSituType::insitutype(x = as.matrix(counts), 
                              neg = Matrix::rowMeans(negcounts), 
                              reference_profiles = refprofiles,
                              update_reference_profiles = FALSE,
                              n_clust = 0,  # don't fit any additional clusters
                              assay_type = "rna")
```


First we choose cell type colors. Doing this by hand is usually desirable later on. But for now, before we've finalized
our cell typing results, we can just use an automated approach.

```{r choosecolors}
cols <- InSituType::colorCellTypes(freqs = table(res$clust), palette = "brewers")
cols
```

## QC of cell typing results

Now we enter the crucial QC phase. Below we'll print out a variety of QC plots and discuss their interpretation. 
We start with UMAP and "flightpath" plots. Flightpath plots are specific to methods like Insitutype which score every cell's probability of belonging to every cluster. 
They show the tendency of different cell types to be confused with each other. 


```{r qcplots, fig.dim=c(8,8)}
# flightpath
flightpath <- flightpath_layout(logliks = res$logliks, profiles = res$profiles)
par(mar = c(0,0,0,0))
plot(flightpath$cellpos, pch = 16, cex = 0.1, col = cols[res$clust])
text(flightpath$clustpos[, 1], flightpath$clustpos[, 2], rownames(flightpath$clustpos), cex = 0.7)

# umap
#plot(um, pch = 16, cex = 0.1, col = cols[res$clust])
#for (cell in unique(res$clust)) {
#  text(median(um[res$clust == cell, 1]), median(um[res$clust == cell, 2]), cell, cex = 0.7)  
#}

#plot(xy, pch = 16, cex = 0.1, col = cols[res$clust])


```

Higher rates of confusion are seen between closely-related cell types, e.g. Distinct proximal tubule types A and B. 
But for the most part this is a good result, with no indication that any clusters are irredeemably confused. 

Next we draw a heatmap of the cluster profiles. These are helpful for confirming that clusters have the expected marker genes,
or for understanding what cell types unknown clusters are. It's often useful to print out a very long pdf of this heatmap in
which every gene name is visible. 

```{r heatmap}
# profiles heatmap
#pdf(paste0(mydir, "/results/celltypeprofiles.pdf"), height = 20)
pheatmap::pheatmap(sweep(res$profiles, 1, pmax(apply(res$profiles, 1, max), 0.2), "/")[apply(res$profiles, 1, max) > 0.2],  
                   fontsize_row = 4,
                   col = colorRampPalette(c("white", "darkblue"))(100))  
#dev.off()
# (the use of pmax(..., 0.2) prevents genes with very low signal in all cell types from appearing exciting)
```

And finally, we'll want to see every cell type's spatial spread. Code like the below is good for this:

```{r spatialplots, eval = FALSE}
for (cell in unique(res$clust)) {
  png(paste0(mydir, "/results/celltypev1_", cell, ".png"), 
      width = diff(range(xy[,1]))*.7, height = diff(range(xy[,2]))*.7, units = "in", 
      res = 400)  # res of 400 is pretty good, though generally not publishable
  par(mar = c(0,0,0,0))
  plot(xy, pch = 16, col = "grey80", cex = 0.1,
       xlab = "", ylab = "", xaxt = "n", yaxt = "n")
  points(xy[res$clest == cell, ], pch = 16, cex = 0.2, col = cols[cell])
  legend("top", legend = cell)
  dev.off()
}
```

## Refining cell type results

