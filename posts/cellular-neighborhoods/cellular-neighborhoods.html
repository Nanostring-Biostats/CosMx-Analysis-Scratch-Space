<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8" />
<meta name="generator" content="quarto-1.3.433" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

<meta name="author" content="Patrick Danaher" />
<meta name="dcterms.date" content="2024-10-17" />
<meta name="description" content="An introduction to “cellular neighborhoods” and their many uses in analysis." />

<title>Blog – Cellular neighborhoods: a useful and straightforward analysis framework</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>

<!-- htmldependencies:E3FAD763 -->
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-29W4MW0Y2W"></script>

<script type="text/plain" cookie-consent="tracking">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-29W4MW0Y2W', { 'anonymize_ip': true});
</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"simple",
  "consent_type":"implied",
  "palette":"light",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary","functionality","tracking","targeting"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  });
});
</script> 
  


</head>

<body>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="/index.html" class="navbar-brand navbar-brand-logo">
    <img src="/./assets/logo_Bruker_white.png" alt="" class="navbar-logo" />
    </a>
    <a class="navbar-brand" href="/index.html">
    <span class="navbar-title">Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse"
  aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"
  onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="/license.html" rel="" target="">
 <span class="menu-text">License</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="/link-to-code.html" rel="" target="">
 <span class="menu-text">Code</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="/about.html" rel="" target="">
 <span class="menu-text">Browse Posts by Topic</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space" rel="" target=""><i 
  class="bi bi-github" 
  role="img" 
>
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/nanostringtech" rel="" target=""><i 
  class="bi bi-twitter" 
  role="img" 
>
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/company/bruker-spatial" rel="" target=""><i 
  class="bi bi-linkedin" 
  role="img" 
>
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="/index.xml" rel="" target=""><i 
  class="bi bi-rss" 
  role="img" 
>
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div id="quarto-toc-target"></div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" ></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default toc-left">
  <div class="quarto-title-banner">
    <div class="quarto-title column-body">
      <h1 class="title">Cellular neighborhoods: a useful and straightforward analysis framework</h1>
                  <div>
        <div class="description">
          An introduction to “cellular neighborhoods” and their many uses in analysis.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">overview</div>
              </div>
                  </div>
  </div>
    
  <div class="quarto-title-meta-author">
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-heading">Affiliations</div>
    
      <div class="quarto-title-meta-contents">
      <p class="author">Patrick Danaher <a href="https://orcid.org/0000-0002-2844-5883" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
    </div>
      <div class="quarto-title-meta-contents">
          <p class="affiliation">
              NanoString, a Bruker Company
            </p>
          <p class="affiliation">
              Github: <a href="https://github.com/patrickjdanaher" target="_blank">patrickjdanaher</a>
            </p>
        </div>
      </div>

  <div class="quarto-title-meta">

        
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 17, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header>
<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#tools-for-analyzing-cellular-neighborhoods" id="toc-tools-for-analyzing-cellular-neighborhoods"><span class="header-section-number">2</span> Tools for analyzing cellular neighborhoods:</a>
  <ul>
  <li><a href="#defining-a-cells-neighbors" id="toc-defining-a-cells-neighbors"><span class="header-section-number">2.1</span> Defining a cell’s neighbors</a>
  <ul>
  <li><a href="#subsampling-neighbors-to-minimize-spatial-auto-correlation" id="toc-subsampling-neighbors-to-minimize-spatial-auto-correlation"><span class="header-section-number">2.1.1</span> Subsampling neighbors to minimize spatial auto-correlation</a></li>
  </ul></li>
  <li><a href="#summarizing-a-cells-neighbors-to-define-its-spatial-context" id="toc-summarizing-a-cells-neighbors-to-define-its-spatial-context"><span class="header-section-number">2.2</span> Summarizing a cell’s neighbors to define its spatial context</a></li>
  </ul></li>
  <li><a href="#analyzing-the-spatial-context-matrix" id="toc-analyzing-the-spatial-context-matrix"><span class="header-section-number">3</span> Analyzing the spatial context matrix:</a>
  <ul>
  <li><a href="#visualization" id="toc-visualization"><span class="header-section-number">3.0.1</span> Visualization</a></li>
  <li><a href="#spatial-clustering-niche-analysis" id="toc-spatial-clustering-niche-analysis"><span class="header-section-number">3.0.2</span> Spatial clustering / niche analysis</a></li>
  <li><a href="#umaps" id="toc-umaps"><span class="header-section-number">3.0.3</span> UMAPs:</a></li>
  <li><a href="#clustering-genes" id="toc-clustering-genes"><span class="header-section-number">3.0.4</span> Clustering genes:</a></li>
  <li><a href="#evaluating-single-genes-for-spatial-autocorrelation" id="toc-evaluating-single-genes-for-spatial-autocorrelation"><span class="header-section-number">3.0.5</span> Evaluating single genes for spatial autocorrelation:</a></li>
  <li><a href="#differential-expression" id="toc-differential-expression"><span class="header-section-number">3.0.6</span> Differential expression</a></li>
  <li><a href="#ligand-receptor-analysis" id="toc-ligand-receptor-analysis"><span class="header-section-number">3.0.7</span> Ligand-receptor analysis:</a></li>
  </ul></li>
  <li><a href="#recommendation-spatial-clustering-niche-analysis" id="toc-recommendation-spatial-clustering-niche-analysis"><span class="header-section-number">4</span> Recommendation: spatial clustering / niche analysis</a></li>
  <li><a href="#computational-considerations" id="toc-computational-considerations"><span class="header-section-number">5</span> Computational considerations</a></li>
  </ul>
</nav>
<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>The literature is becoming crowded with analysis tools employing elaborate techniques (graphical neural networks, Fourier transforms, hidden Markov random fields) to solve straightforward problems (e.g. spatial clustering or seeking spatially auto-correlated genes). While these methods promise more optimal performance, simpler techniques have a different virtue: they make analyses easier to understand, both for analysts and for their eventual audiences. In this spirit, we recommend “cellular neighborhoods” as an framework for diverse analyses. This approach is easy to implement, straightforward to riff on, and computationally efficient</p>
<p>Cellular neighborhood analysis begins with two steps:</p>
<ol type="1">
<li>Define each cell’s neighboring cells.</li>
<li>Create a new matrix encoding cells’ “spatial contexts”. To do this, we compute summaries of each cell’s neighbors, reporting for example their average expression profile or the abundance of different cell types within them.</li>
</ol>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img src="./figures/cartoon.png" class="img-fluid" style="width:120.0%" /></p>
<figcaption>Left: example of a cellular neighborhood defined as a cell’s 50 nearest neighbors. Right: the mean expression profile of those neighbors is used to define the cell’s spatial context. This ‘mean neighborhood expression’, calculated separately for all cells in the dataset, defines a new data matrix.</figcaption>
</figure>
</div>
</div>
</div>
<p>Once we’ve obtained a matrix of spatial context data, myriad analyses become possible. We can:</p>
<ul>
<li>Plot spatially smoothed expression to make spatial expression patterns for visually clear</li>
<li>Derive spatial clusters / niches</li>
<li>Find spatially auto-correlated genes / sets of genes</li>
<li>Set up interesting differential expression problems, asking how cells modulate expression in response to their spatial context</li>
<li>Explore ligand-receptor interactions</li>
</ul>
<p>Many of these analyses are achieved by simply applying techniques from single cell analyses, for example clustering the rows (cells) or columns (genes) of the matrix.</p>
</section>
<section id="tools-for-analyzing-cellular-neighborhoods" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Tools for analyzing cellular neighborhoods:</h1>
<p>A small R package implementing the building blocks of cellular neighborhood analysis is <a href="/_code/cellular-neighborhoods" target="_blank">here</a>.</p>
<p>To install it:</p>
<div class="cell">
<div class="sourceCode" id="cb1"><pre class="sourceCode r cell-code"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>devtools<span class="sc">::</span><span class="fu">install_github</span>(<span class="st">&quot;https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/tree/Main/_code/cellular-neighborhoods&quot;</span>)</span></code></pre></div>
</div>
<p>To set up our examples, let’s load the package and open its data:</p>
<div class="cell">
<div class="sourceCode" id="cb2"><pre class="sourceCode r cell-code"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(CellularNeighborhoods)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(cosmx_kidney)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>annot <span class="ot">&lt;-</span> cosmx_kidney<span class="sc">$</span>annot</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(annot) <span class="ot">&lt;-</span> annot<span class="sc">$</span>cell_ID</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>counts <span class="ot">&lt;-</span> cosmx_kidney<span class="sc">$</span>counts</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>celltype <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(cosmx_kidney<span class="sc">$</span>annot<span class="sc">$</span>celltype)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>xy <span class="ot">&lt;-</span> cosmx_kidney<span class="sc">$</span>xy</span></code></pre></div>
</div>
<p>Now we’re ready to demonstrate the basics:</p>
<section id="defining-a-cells-neighbors" class="level2" data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span> Defining a cell’s neighbors</h2>
<p>Convenient approaches to define a cell’s neighbors include the “K-nearest” approach (we usually use the nearest 50 neighbors) and a radius-based approach. We prefer the K-nearest neighbors approach, mainly because radius-based neighborhoods tend to vary widely in the number of cells they contain, and neighborhoods of very few cells are statistically unstable.</p>
<p>The size of a neighborhood is up to the analyst’s discretion. Try to choose a neighborhood size that reflects your understanding of biology and that makes sense for your biological question. There is a Goldilocks zone, however: very small neighborhoods produce sparse and noisy data, and very large neighborhoods become inaccurate representations of a cell’s 3D surroundings. (The problem with large neighborhoods: the area of your circular neighborhood increases with the square of the radius, but the volume of the corresponding (unobserved) 3D tissue region increases with the cube of the radius. This means that the larger the radius, the less of your 3D neighborhood falls in the narrow tissue slide you’ve assayed, and the more it consists of unseen cells increasingly far away in the Z-dimension.)</p>
<p>Here’s code for defining cellular neighborhoods:</p>
<div class="cell">
<div class="sourceCode" id="cb3"><pre class="sourceCode r cell-code"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># define neighbors using a K-nearest approach:</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>neighbors.nearest50 <span class="ot">&lt;-</span> <span class="fu">nearestNeighborGraph</span>(<span class="at">x =</span> xy[, <span class="dv">1</span>], <span class="at">y =</span> xy[, <span class="dv">2</span>], <span class="at">N =</span> <span class="dv">50</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># define using a radius-based approach:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>neighbors.radiusbased <span class="ot">&lt;-</span> <span class="fu">radiusBasedGraph</span>(<span class="at">x =</span> xy[, <span class="dv">1</span>], <span class="at">y =</span> xy[, <span class="dv">2</span>], <span class="at">R =</span> <span class="fl">0.05</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># the output is a sparse matrix of cells * cells:</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(neighbors.nearest50)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Formal class &#39;dgCMatrix&#39; [package &quot;Matrix&quot;] with 6 slots
  ..@ i       : int [1:327750] 1 22 30 40 54 59 62 63 73 78 ...
  ..@ p       : int [1:6556] 0 29 60 89 114 141 181 207 239 276 ...
  ..@ Dim     : int [1:2] 6555 6555
  ..@ Dimnames:List of 2
  .. ..$ : NULL
  .. ..$ : NULL
  ..@ x       : num [1:327750] 0.0603 0.0405 0.0135 0.0379 0.0179 ...
  ..@ factors : list()</code></pre>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode r cell-code"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># compare the number of neighbors found by each approach:</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(Matrix<span class="sc">::</span><span class="fu">rowSums</span>(neighbors.nearest50))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.230   1.595   1.742   1.784   1.927   5.360 </code></pre>
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode r cell-code"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(Matrix<span class="sc">::</span><span class="fu">rowSums</span>(neighbors.radiusbased))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  0.000   1.234   1.514   1.512   1.781   2.772 </code></pre>
</div>
</div>
<section id="subsampling-neighbors-to-minimize-spatial-auto-correlation" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1"><span class="header-section-number">2.1.1</span> Subsampling neighbors to minimize spatial auto-correlation</h3>
<p>An occasionally important detail:</p>
<p>In “Mitigating autocorrelation during spatially resolved transcriptomics data analysis” (bioRvix), Maher et al. describe an inconvenient tendency of spatial context matrices: because neighboring cells have largely the same neighbors, their entries in the spatial context matrix are correlated. This correlation between neighbors proves a substantial barrier to distance-based analyses like UMAP or Leiden clustering, producing UMAPs where all points fall in a highly-connected blob and generally poor Leiden performance. (However, for most analyses, correlation between neighboring cells’ spatial context vectors doesn’t seem to have much impact.) They propose that by defining each cell’s neighborhood as a random subset of its nearest neighbors, they can largely break this correlation between neighbors. They released a python toolkit for this, <a href="https://github.com/wanglab-broad/spin" target="_blank">SPIN</a>.</p>
<p>For R coders, here’s how you would get a neighborhood matrix with random subsetting:</p>
<div class="cell">
<div class="sourceCode" id="cb9"><pre class="sourceCode r cell-code"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>subsetted_neighbors <span class="ot">&lt;-</span> <span class="fu">subsampleNeighborsByRow</span>(<span class="at">neighbors =</span> neighbors.nearest50, <span class="at">p =</span> <span class="fl">0.5</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(Matrix<span class="sc">::</span><span class="fu">rowSums</span>(subsetted_neighbors))</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
 0.5717  0.7919  0.8724  0.8931  0.9709  2.7387 </code></pre>
</div>
</div>
</section>
</section>
<section id="summarizing-a-cells-neighbors-to-define-its-spatial-context" class="level2" data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span> Summarizing a cell’s neighbors to define its spatial context</h2>
<p>Usually, you’ll employ one of two approaches:</p>
<ol type="1">
<li>Report the average expression of neighborhood cells</li>
<li>Report the cell type abundances within the neighborhood cells</li>
</ol>
<p>But more bespoke options are possible. For example, you could:</p>
<ul>
<li>Only record expression of known ligands, under the theory that they’re mainly responsible for cell-cell communication.</li>
<li>Only record genes from a pathway of interest</li>
<li>Record QC metrics like the rate of flagged cells, or total counts per cell, or total negprobe counts per cell.</li>
<li>Create a hybrid matrix including both cell type abundances and expression of selected genes.</li>
<li>Instead of computing means, look at SD or covariance of gene expression within a neighborhood.</li>
</ul>
<p>The main takeaway here is that once you’ve defined cellular neighborhoods, it’s incredibly simply to extract all manner of variables from them, giving you great flexibility in how you pose biological questions.</p>
<p>You can implement the basic formats of spatial context matrices as follows:</p>
<div class="cell">
<div class="sourceCode" id="cb11"><pre class="sourceCode r cell-code"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># mean neighborhood expression:</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>spatialcontext_expression <span class="ot">&lt;-</span> <span class="fu">get_neighborhood_expression</span>(counts, neighbors.nearest50)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co"># mean cell type abundances:</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>spatialcontext_celltypes <span class="ot">&lt;-</span> <span class="fu">neighbor_tabulate</span>(annot<span class="sc">$</span>celltype, neighbors.nearest50)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co"># spatial context matrices are dense:</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(spatialcontext_expression)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> num [1:6555, 1:11] 0.16 0.24 0.4 0.28 0.22 0.4 0.32 0.38 0.28 0.34 ...
 - attr(*, &quot;dimnames&quot;)=List of 2
  ..$ : NULL
  ..$ : chr [1:11] &quot;ITGAV&quot; &quot;ITGA3&quot; &quot;SPOCK2&quot; &quot;SPP1&quot; ...</code></pre>
</div>
<div class="sourceCode" id="cb13"><pre class="sourceCode r cell-code"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(spatialcontext_celltypes)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> num [1:6555, 1:26] 24 34 17 36 29 11 36 35 19 39 ...
 - attr(*, &quot;dimnames&quot;)=List of 2
  ..$ : NULL
  ..$ : chr [1:26] &quot;PCT&quot; &quot;Parietal.epithelium&quot; &quot;Connecting.tubule&quot; &quot;Type.B.intercalated.cell&quot; ...</code></pre>
</div>
</div>
</section>
</section>
<section id="analyzing-the-spatial-context-matrix" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Analyzing the spatial context matrix:</h1>
<p>Now that we’ve got a spatial context matrix, we can play all our usual matrix analysis games with it. Brief descriptions follow:</p>
<section id="visualization" class="level3" data-number="3.0.1">
<h3 data-number="3.0.1"><span class="header-section-number">3.0.1</span> Visualization</h3>
<p>Plotting genes’ values in the spatial context matrix, rather than their single cell expression values, often produces smoother, cleaner representations of their spatial patterns.</p>
</section>
<section id="spatial-clustering-niche-analysis" class="level3" data-number="3.0.2">
<h3 data-number="3.0.2"><span class="header-section-number">3.0.2</span> Spatial clustering / niche analysis</h3>
<p>This is an exercise in clustering the rows (cells) of the spatial context matrix. The Mclust library works well here. If you use subsetted neighbors (via the function), then Louvain and Leiden clustering will also work.</p>
</section>
<section id="umaps" class="level3" data-number="3.0.3">
<h3 data-number="3.0.3"><span class="header-section-number">3.0.3</span> UMAPs:</h3>
<p>Two approaches lead to informative UMAP projections of spatial context matrices:</p>
<ol type="1">
<li>Use to squash autocorrelation.</li>
<li>Simply plot a UMAP of a random subset of cells.</li>
</ol>
</section>
<section id="clustering-genes" class="level3" data-number="3.0.4">
<h3 data-number="3.0.4"><span class="header-section-number">3.0.4</span> Clustering genes:</h3>
<p>To find sets of genes that are correlated with each other in space, we recommend the <a href="https://github.com/Nanostring-Biostats/InSituCor" target="_blank">InSituCor library</a>, which applies many of the functions shown here and implements other insights to get more informative results.</p>
</section>
<section id="evaluating-single-genes-for-spatial-autocorrelation" class="level3" data-number="3.0.5">
<h3 data-number="3.0.5"><span class="header-section-number">3.0.5</span> Evaluating single genes for spatial autocorrelation:</h3>
<p>Lots of well-considered packages are available for this task, though cellular neighborhoods can also be used. Simply take the correlation between a gene’s (normalized) single cell expression and its mean expression across cellular neighborhoods, i.e. its column in the spatial context matrix.</p>
</section>
<section id="differential-expression" class="level3" data-number="3.0.6">
<h3 data-number="3.0.6"><span class="header-section-number">3.0.6</span> Differential expression</h3>
<p>Spatial context variables, for example abundance of a cell type of interest or expression of a gene of interest, are well-suited for use as predictors in differential expression analysis. For example, you might model how tumor cell gene expression changes in response to the number of neighboring T-cells, or to neighborhood expression of interferon gamma.</p>
</section>
<section id="ligand-receptor-analysis" class="level3" data-number="3.0.7">
<h3 data-number="3.0.7"><span class="header-section-number">3.0.7</span> Ligand-receptor analysis:</h3>
<p>The cellular neighborhood framework lets us examine ligand-receptor interactions in a variety of ways:</p>
<ul>
<li>We can score cellular neighborhoods for concurrent expression of a LR pair</li>
<li>We can study whether a LR pair tends to be expressed in the same neighborhoods. (Again, InSituCor is well-crafted for this task.)</li>
<li>You might reasonably just look at a ligand’s neighborhood expression levels as indicative of the LR signaling cells are subject to. (You might do this if the single cell expression of the Receptor gene is problematically noisy, or if you’re willing to assume that all the cells you’re analyzing have at least <em>some</em> receptor, and the biologically interesting question is how much ligand they’re exposed to.)</li>
</ul>
</section>
</section>
<section id="recommendation-spatial-clustering-niche-analysis" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Recommendation: spatial clustering / niche analysis</h1>
<p>“Niche analysis” is the task of classifying cellular neighborhoods, usually via cluster analysis. Anecdotally, scientists seem to be making very effective use of this technique. Spatial transcriptomics data is complex, and it’s a convenient simplification to say things like, “We found a T-cell-enriched niche”, or, “This niche is more common in higher-grade disease”. This technique is particularly useful in large studies, where much of analysis focuses on tissue-level attributes. In this setting, it’s very convenient to summarize tissues with their relative abundances of different niches.</p>
</section>
<section id="computational-considerations" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Computational considerations</h1>
<p>Single cell expression data is sparse, and so can be stored in sparse matrix format for huge memory savings. But a spatial context matrix reporting average neighborhood expression is dense, and for larger datasets can overwhelm even generously-allotted memory. We recommend two countermeasures:</p>
<ol type="1">
<li>Subsetting: many analyses don’t need to use every cell in a dataset: taking results from just thousands or tens of thousands of cells produces sufficiently stable summary statistics. InSituCor, for example, defaults to calculating spatial context matrix for just a subset of 5000 cells.</li>
</ol>
<p>Here’s how you would get a spatial context for a subset:</p>
<div class="cell">
<div class="sourceCode" id="cb15"><pre class="sourceCode r cell-code"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>sub <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(counts), <span class="dv">1000</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>subsampled_spatialcontext <span class="ot">&lt;-</span> <span class="fu">get_neighborhood_expression</span>(</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">counts =</span> counts,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">neighbors =</span> neighbors.nearest50[sub, ])</span></code></pre></div>
</div>
<ol start="2" type="1">
<li>On-the-fly calculations: it’s computationally quick to compute things like mean neighborhood expression or mean neighborhood cell type abundance. Rather than storing these matrices, calculate them anew every time you need them.</li>
</ol>
<div id="quarto-navigation-envelope" class="hidden">
<p><span class="hidden" data-render-id="quarto-int-sidebar-title">Blog</span> <span class="hidden" data-render-id="quarto-int-navbar-title">Blog</span> <span class="hidden" data-render-id="quarto-int-navbar:License">License</span> <span class="hidden" data-render-id="quarto-int-navbar:/license.html">/license.html</span> <span class="hidden" data-render-id="quarto-int-navbar:Code">Code</span> <span class="hidden" data-render-id="quarto-int-navbar:/link-to-code.html">/link-to-code.html</span> <span class="hidden" data-render-id="quarto-int-navbar:Browse Posts by Topic">Browse Posts by Topic</span> <span class="hidden" data-render-id="quarto-int-navbar:/about.html">/about.html</span> <span class="hidden" data-render-id="quarto-int-navbar:https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space">https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space</span> <span class="hidden" data-render-id="quarto-int-navbar:https://twitter.com/nanostringtech">https://twitter.com/nanostringtech</span> <span class="hidden" data-render-id="quarto-int-navbar:https://www.linkedin.com/company/bruker-spatial">https://www.linkedin.com/company/bruker-spatial</span> <span class="hidden" data-render-id="quarto-int-navbar:/index.xml">/index.xml</span> <span class="hidden" data-render-id="footer-center-/license.html">License</span></p>
</div>
<div id="quarto-meta-markdown" class="hidden">
<p><span class="hidden" data-render-id="quarto-metatitle">Blog - Cellular neighborhoods: a useful and straightforward analysis framework</span> <span class="hidden" data-render-id="quarto-twittercardtitle">Blog - Cellular neighborhoods: a useful and straightforward analysis framework</span> <span class="hidden" data-render-id="quarto-ogcardtitle">Blog - Cellular neighborhoods: a useful and straightforward analysis framework</span> <span class="hidden" data-render-id="quarto-metasitename">Blog</span> <span class="hidden" data-render-id="quarto-twittercarddesc">An introduction to “cellular neighborhoods” and their many uses in analysis.</span> <span class="hidden" data-render-id="quarto-ogcardddesc">An introduction to “cellular neighborhoods” and their many uses in analysis.</span></p>
</div>
</section>

</main> <!-- /main -->
<script id = "quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="/license.html">
 License
    </a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>

</body>

</html>