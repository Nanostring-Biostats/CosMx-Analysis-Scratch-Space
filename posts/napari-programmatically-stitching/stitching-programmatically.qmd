---
title: "Stitching napari images programmatically"
author:
  - name: Evelyn Metzger
    orcid: 0000-0002-4074-9003
    affiliations: 
      - ref: nstg
      - ref: eveilyeverafter
toc: true
toc-title: Contents
toc-depth: 3
toc-expand: 2
toc-location: left
number-sections: true
number-depth: 4
date: "2024-05-24"
categories: [napari]
draft: false
image: figures/fig-stitch-single-slide.png
code-fold: false
description: Did you know that napari-cosmx can stitch images from AtoMx programmatically? In this post I show you how.
freeze: false
#page-layout: full
editor: 
  markdown: 
    wrap: 72
---

# Introduction

In our [first napari-series
post](../using-napari-for-cosmx-data/index.qmd){target="_blank"}, we
introduced our `napari-cosmx` plugin that lets you view and analyze
CosMx™ SMI data that has been exported from AtoMx™ SIP. There, users can
"stitch" raw data from AtoMx using a widget within the Graphical User
Interface (GUI).

In some settings, such as linux servers, it's not possible to use a GUI
to stitch. In other cases, one might be interested in programmatically
stitching many slides without the need to use the GUI. And finally, with
the GUI-based approach, we had to start [from an existing
slide](../using-napari-for-cosmx-data/index.qmd#sec-loading-slides){target="_blank"}.
This extra step was necessary because the widget used to stitch was only
available within the plugin itself and a slide is needed to launch the
plugin.

It's possible to stitch without the need of a GUI. This post is for
people familiar with programming in python but I try to make it
approachable for non-experts. The [GUI
approach](../using-napari-for-cosmx-data/index.qmd){target="_blank"} is
recommended for most users as it eliminates much of the installation
that is needed to stitch slides programmatically and has been tested on
more machines.

-   @sec-installation Install napari and `napari-cosmx` using a virtual
    environment
-   @sec-single-slide How to stitch a single slide within python
-   @sec-multiple-slides How to stitch multiple slides serially with
    python

::: callout-note
Note: throughout this post I use the term "stitching" for brevity to
refer to *both* the stitching (`stitch-images`) and the reading of
targets (`read-targets`). These are two separate package scripts but are
typically executed back-to-back.
:::

# Installation {#sec-installation}

Before we begin stitching, we need to install napari and the
`napari-cosmx` plugin. I've found that the success of installation
depends on the particular package versions and the version of python and
we recommend using a virtual environment such as python's built in
[venv](https://docs.python.org/3/library/venv.html){target="_blank"} or
[miniconda](https://docs.anaconda.com/free/miniconda/){target="_blank"}.
Of those two virtual environment options, conda allows us the
flexibility to select a specific version on python so this post will use
conda.

I've tested the instructions below on MacOS (v12.5.1) and Windows (11
Pro). For Mac, we'll make use of the built-in `Terminal`. For Windows
we'll used [VS
Code](https://code.visualstudio.com/download){target="_blank"} for this
post.

## Create Virtual Environment

::: {.panel-tabset group="language"}
### Mac/Unix

In the `assests > napari-cosmx releases` folder, there's a yaml file
named `napari-cosmx-env.yml` that will use to set the environment named
`napari-cosmx-env`.

```{bash}
#| eval: false
#| label: mac venv creation and activation

conda env create --file /path/to/-napari-cosmx-env.yml
conda activate napari-cosmx-env

# # built-in venv alternative
# python3.9 -m venv napari-cosmx-env
# source napari-cosmx-env/bin/activate

```

### Windows

VS Code has a useful
[page](https://code.visualstudio.com/docs/python/environments){target="_blank"}
on virtual environments and we'll use some of those elements to create
and activate ours.

Open VS Code and navigate to a project folder. Open the Command Pallete
and type `Python: Create Environment`. Choose conda and select Python
3.10. When it is finished creating the `.conda` folder within your
project, open the `Command Prompt` terminal (`Terminal` \>
`New Terminal`). This will open a terminal within your project. To
activate the virtual environment and install napari 0.4.17, type:

```{bash}
#| eval: false
#| label: windows venv activation

conda activate .\.conda
conda install -c conda-forge napari=0.4.17
```
:::

We can optionally confirm that napari was installed and working using
`ipython`. @fig-confirmation shows the results of the code below which
launched the napari viewer and added one of the example image layers:
astronaut. To access the `ipython` interpreter, simply type `ipython`
within your virtual environment (and `exit()` to exit).

```{python}
#| label: confirm napari
#| eval: false

import napari
from skimage import data

viewer, image_layer = napari.imshow(data.astronaut())
```

```{r}
#| eval: true
#| echo: false
#| label: "fig-confirmation"
#| fig-cap: "Optionally launching a built-in image to ensure that napari was successfully installed. Shown here is an image of [Elleen Collins](https://www.nasa.gov/former-astronaut-eileen-collins/){target='_blank'}."

knitr::include_graphics("./figures/fig-confirmation.png")
```

## Installing `napari-cosmx`

Now that we have our virtual environment installed, activated, and
napari installed, we need to install the plugin. The file (and license)
can be found in [asests/napari-cosmx
releases](https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/tree/Main/assets/napari-cosmx%20releases){target="_blank"}
in the source code of our scratch space repository. Download this `whl`
file, return to bash/cmd, and install it like this:

::: {.panel-tabset group="language"}
### Mac/Unix

```{bash}
#| label: install napari-cosmx mac
#| eval: false

pip install /path/to/your/napari_CosMx-0.4.17.0-py3-none-any.whl
```

### Windows

```{bash}
#| label: install napari-cosmx windows
#| eval: false

pip install "C:\path\to\your\napari_CosMx-0.4.17.0-py3-none-any.whl"

```
:::

There are a few package scripts that are installed within your virtual
environment. The two we'll use on today is `stitch-images` and
`read-targets`.

# Stitching a single slide in python {#sec-single-slide}

Before we stitch multiple slides, let's stitch a single slide within
python. In the code below, we point python to the location of our raw
data slide folder. This folder will have subfolders `CellStatsDir`,
`RunSummary`, and `AnalysisResults`.

In the user-defined options section of this script, be sure to configure
the paths as needed.

```{python}
#| label: stitch one slide
#| eval: false

import numpy
import pandas as pd
import os
from os import listdir
from glob import iglob

### User-defined options

## Path to your slide folder
# SlideDir = "path/to/your/slide/raw/data" # Mac/Unix OR
# SlideDir = r"C:\path\to\your\slide\raw\data" # Windows

## Output path
# SlideOutputDir = "/path/to/new/directory/to/store/napari/files" # Mac/Unix OR
# SlideOutputDir = r"C:\path\to\new\directory\to\store\napari\files" # Windows

### Processing

if not os.path.exists(SlideOutputDir):
  print("Creating output folder")
  os.makedirs(SlideOutputDir)

CellStatsDir = os.path.join(SlideDir, "CellStatsDir")
RunSummaryDir = os.path.join(SlideDir, 'RunSummary')
AnalysisDirParent = os.path.join(SlideDir, 'AnalysisResults')
AnalysisDirSubBasename = [i for i in listdir(AnalysisDirParent) if not i.startswith('.')]
AnalysisDir = os.path.join(AnalysisDirParent, AnalysisDirSubBasename[0])

cmd_stitch = 'stitch-images -i "' + CellStatsDir + '" -f "' + RunSummaryDir + '" -o ' + SlideOutputDir
!{cmd_stitch}

cmd_read_targets = 'read-targets "' + AnalysisDir + '"' + ' -o ' + SlideOutputDir
!{cmd_read_targets}

```

In the script above, we directed python to the input (`SlideDir`) and
the output (`SlideOutputDir`) folders and then we called the package
scripts that we installed moments ago. The first package script builds
the zarr structure and the second one creates the targets.hdf5 file.

We can also call these package scripts directly in our terminal.

```{bash}
#| label: call package scripts
#| eval: false

stitch-images -i <path to CellStats dir> -f <path to RunSummary dir> -o <path to output dir>
read-targets <path to AnalysisResults/sub dir> - o <path to output dir>
```

For more information, and advanced options, run `stitch-image --help` or
`read-targets --help`

```{bash}
#| label: call package scripts help 1
#| eval: false

stitch-images --help
```

```         
usage: stitch-images [-h] [-i INPUTDIR] [--imagesdir IMAGESDIR] [-o OUTPUTDIR] [-f OFFSETSDIR] [-l] [-u UMPERPX] [-z ZSLICE] [--dotzarr]

Tile CellLabels and morphology TIFFs.

optional arguments:
  -h, --help            show this help message and exit
  -i INPUTDIR, --inputdir INPUTDIR
                        Required: Path to CellLabels and morphology images.
  --imagesdir IMAGESDIR
                        Optional: Path to morphology images, if different than inputdir.
  -o OUTPUTDIR, --outputdir OUTPUTDIR
                        Required: Where to create zarr output.
  -f OFFSETSDIR, --offsetsdir OFFSETSDIR
                        Required: Path to latest.fovs.csv directory.
  -l, --labels          
                        Optional: Only stitch labels.
  -u UMPERPX, --umperpx UMPERPX
                        Optional: Override image scale in um per pixel.
                        Instrument-specific values to use:
                        -> beta04 = 0.1228
  -z ZSLICE, --zslice ZSLICE
                        Optional: Z slice to stitch.
  --dotzarr             
                        Optional: Add .zarr extension on multiscale pyramids.
```

```{bash}
#| label: call package scripts help 2
#| eval: false

read-targets --help
```

```         
usage: read-targets [-h] [-o OUTPUTDIR] [--filename FILENAME] folder

Read decoded targets and write to hdf5

positional arguments:
  folder                Voting folder

optional arguments:
  -h, --help            show this help message and exit
  -o OUTPUTDIR, --outputdir OUTPUTDIR
                        Where to write hdf5 file
  --filename FILENAME   Name for hdf5 file
```

## Viewing the results {#sec-launching-napari-cosmx-from-python}

We can launch the plugin directly from `ipython`. In the code below, I
instantiated a `Gemini` class object, turned off the segmentation and
FOV labels layers, added the PanCK and DNA channels and manually
adjusted the contrast of PanCK. Finally, I launched the widget for
further exploration. These methods and more will be part of a future
blog post but I include them here as a preview. You'll note in the
widget section that the `Color Cells` widget is blank. That's because we
didn't create metadata for this slide (*i.e.*, it was not present in the
raw data). For an example of adding metadata, see the [Adding and
viewing
metadata](../using-napari-for-cosmx-data/index.qmd#sec-adding-metadata){target="_blank"}
section from the first post.

```{python}
#| label: view one slide
#| eval: false

from importlib.metadata import metadata
import numpy
import pandas as pd
import os
from napari_cosmx.gemini import Gemini

napari_files_path  = 'your/SlideOutputDir/from/above'
gem = Gemini(napari_files_path)
gem.viewer.layers['Segmentation'].visible = False
gem.viewer.layers['FOV labels'].visible = False
gem.add_channel('PanCK', colormap = 'green')
panck = Slide.viewer.layers['PanCK']
panck.contrast_limits = [1000, 50000]
gem.add_channel('DNA', colormap = 'bop blue')
gem.show_widget()

```

```{r}
#| eval: true
#| echo: false
#| label: "fig-stitch-single-slide"
#| fig-cap: "The output from a single slide stitching. This image represent an 8-by-8 FOV grid. PanCK and DNA are shown in green and blue, respectively."

knitr::include_graphics("./figures/fig-stitch-single-slide.png")
```

# Stitching multiple slides {#sec-multiple-slides}

We can process several slides serially in python. Let's try it. Let's
say we have a `Batch` directory that contains five slides. Within each
slide there is a folder containing the slide name and another folder
named Logs. Here's what the batch folder structure might look like.

```{bash}
#| label: tree 2
#| eval: false

# tree -f -L 2
.
├── ./AUG29_6K_BRST_PS_S1
│   ├── ./AUG29_6K_BRST_PS_S1/20230829_212648_S1
│   ├── ./AUG29_6K_BRST_PS_S1/Logs
├── ./AUG29_6K_BRST_PS_S2
│   ├── ./AUG29_6K_BRST_PS_S2/20230829_212648_S2
│   ├── ./AUG29_6K_BRST_PS_S2/Logs
├── ./AUG29_6K_BRST_PS_S3
│   ├── ./AUG29_6K_BRST_PS_S3/20230829_212648_S3
│   ├── ./AUG29_6K_BRST_PS_S3/Logs
├── ./AUG29_6K_BRST_PS_S4
│   ├── ./AUG29_6K_BRST_PS_S4/20230829_212648_S4
│   ├── ./AUG29_6K_BRST_PS_S4/Logs
├── ./AUG29_6K_BRST_PS_S5
│   ├── ./AUG29_6K_BRST_PS_S5/20230829_212648_S5
│   ├── ./AUG29_6K_BRST_PS_S5/Logs

```

In the python script below, we point `BatchFolder` to the location that
contains these slide folders. We also define `OutputFolder` to store the
napari folders. The script then searches through those folders and
stitches the slides.

<!-- ```{bash} -->

<!-- #| label: make symbolic links to replicate slides (demo) -->

<!-- #| eval: false -->

<!-- #| echo: false -->

<!-- #!/bin/bash -->

<!-- # Define the source folder path -->

<!-- source_folder="./AUG29_13INTEGR_6K_BRST_PS_S2" -->

<!-- # Create symbolic links using a sequence -->

<!-- for i in {3..6}; do -->

<!--   target_folder_name="AUG29_13INTEGR_6K_BRST_PS_S$i" -->

<!--   target_folder_path="./$target_folder_name" -->

<!--   if ln -s "$source_folder" "$target_folder_path"; then -->

<!--     echo "Created symbolic link: $target_folder_path -> $source_folder" -->

<!--   else -->

<!--     echo "Error creating symbolic link: $?" -->

<!--   fi -->

<!-- done -->

<!-- ``` -->

```{python}
#| label: stitch multiple slides
#| eval: false

import numpy
import pandas as pd
import os
from os import listdir
from glob import iglob

# Directory containing multiple slides
BatchFolder = '/directory/containing/multiple/slides'
BatchFolder = r"C:\directory\containing\multiple\slides"

# Output path
OutputFolder = '/path/to/output/directory'
OutputFolder = r"C:\path\to\output\directory"

### Functions

def check_folder(path: str) -> bool:
  """ Checks if a selected folder is a valid slide.

      Description: 
          A folder is a valid slide if it has the following folders:
          CellStatsDir, AnalysisResults/*, and RunSummary
        
      Returns:
          bool: True if valid, False if not valid
  """
  isValid = True
  if not os.path.isdir(path + '/CellStatsDir'):
    print("No valid CellStatsDir")
    isValid = False
  if not os.path.isdir(path + '/RunSummary'):
    print("No valid RunSummary")
    isValid = False 
  if not os.path.isdir(path + '/AnalysisResults'):
    print("No valid AnalysisResults Parent folder")
    isValid = False
  else: 
      # check if /AnalysisResults/<random_subfolder_name> exists
      analysis_sub_dir = [i for i in listdir(path + '/AnalysisResults') if not i.startswith('.')]
      if(len(analysis_sub_dir)!=1):
        print("No valid AnalysisResults subfolder")
        isValid = False
  return isValid

### Processing

for dir in listdir(BatchFolder):
  ParentFolder = os.path.join(BatchFolder, dir)
  if os.path.isfile(ParentFolder):
    print("Skipping file " + dir)
    continue
  else: 
    print('Processing Parent Folder: ' + dir)
    # Process slides within the Parent folder
    for SlideDir in listdir(ParentFolder):
        if os.path.isfile(os.path.join(ParentFolder, SlideDir)):
          print("Skipping file " + SlideDir)
          continue
        else:
          # check that it is a valid slide
          if not check_folder(os.path.join(ParentFolder, SlideDir)):
            print("Skipping folder " + SlideDir)
          else:
            SlideOutputDir = os.path.join(OutputFolder, dir)
            CellStatsDir = os.path.join(ParentFolder, SlideDir, "CellStatsDir")
            RunSummaryDir = os.path.join(ParentFolder, SlideDir, "RunSummary")
            AnalysisDirParent = os.path.join(ParentFolder, SlideDir, 'AnalysisResults')
            AnalysisDirSubBasename = [i for i in listdir(AnalysisDirParent) if not i.startswith('.')]
            AnalysisDir = os.path.join(AnalysisDirParent, AnalysisDirSubBasename[0])
            if os.path.exists(SlideOutputDir):
              print("Skipping output " + SlideOutputDir + ". Folder exists already")
              continue
            else:
              os.makedirs(SlideOutputDir)
              cmd_stitch = 'stitch-images -i "' + CellStatsDir + '" -f "' + RunSummaryDir + '" -o ' + SlideOutputDir
              print(cmd_stitch)
              !{cmd_stitch}
              cmd_read_targets = 'read-targets "' + AnalysisDir + '"' + ' -o ' + SlideOutputDir
              print(cmd_read_targets)
              !{cmd_read_targets}
              print("\n")


```

## Conclusion

In this post, I showed how to prepare napari-ready slide folders from
raw data programmatically. To do this, we used a virtual environment to
install our plugin and created a script to install a single slide
followed by a script to install multiple slides.

I also provided a preview of some of the things you can do with the
`napari-cosmx` plugin, such as add layers, set contrasts, turn off
visibility of layers. Check back later to see how we can use some of
these features (GUI or within python) to interact with and analyze CosMx
data.
