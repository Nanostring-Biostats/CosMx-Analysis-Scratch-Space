[
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "Blog",
    "section": "",
    "text": "NanoString Technologies, Inc. Software License Agreement for Non-Commercial Use\nBy downloading, installing, accessing, modifying or otherwise making use of the Program (defined below), you agree to be bound by the terms and conditions of this Software License Agreement for Non-Commercial Use (this “License”).\n\nDEFINITIONS 1.1. “Affiliate” means, with respect to an individual or entity, another individual or entity: (i) on whose behalf such individual or entity is acting, or (ii) that exercises control, is controlled by, or is under common control with such individual or entity. For the purposes of this definition, the term “control” means the right, whether by ownership, exercise of voting rights, contract, or otherwise, to direct the actions of an individual or entity. 1.2. “Distribute” means to distribute, share, make available, or otherwise provide the Program or Modified Program, as applicable, or access thereto (including via a computer network) to any third party. 1.3. “Licensor” means the individual or entity licensing the rights granted in this License. 1.4. “Licensee” or “you” means the individual or entity receiving or exercising the rights granted under this License, provided that the individual or entity is not a NanoString Competitor. 1.5. “Non-Commercial Use” means any use where profit or other commercial benefit is not a direct or indirect motive or intended result. 1.6. “Modified Program” means a derivative work of, or a work that is based on, uses or incorporates, the Program (whether or not in combination with other works, materials or content). 1.7. “NanoString” means NanoString Technologies, Inc. 1.8. “NanoString Competitor” means any individual or entity that directly or indirectly competes with NanoString or any of NanoString’s Affiliates or whose Affiliate directly or indirectly competes with NanoString or any of NanoString’s Affiliates. 1.9. “Program” means the copyrightable work of authorship, program, code, or software licensed under this License.\nLICENSE 2.1. Grant. Subject to the terms and conditions of this License, Licensor hereby grants to Licensee a worldwide, royalty-free, non-exclusive, revocable license to: (a) use, Distribute, and reproduce the Program, and (b) use, create, Distribute, and reproduce Modified Programs, in each case, solely for your internal, Non-Commercial Use. No rights are granted to NanoString Competitors. 2.2. No Endorsement. Nothing in this License may be construed as permission to assert or imply that Licensor, NanoString, or other contributors to the Program sponsors, endorses, or is otherwise connected with the Licensee or the entity or institution that Licensee represents. 2.3. Trademarks. Trademark rights are not licensed to you under this License. 2.4. Grant of Patent License. Subject to the terms and conditions of this License, NanoString hereby grants to you a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, import, and otherwise transfer the Program, where such license applies only to those patent claims licensable by NanoString that are necessarily infringed by Licensee alone or by combination of its modification(s) to the Program or Modified Program to which such modification(s) was submitted. If you institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program, Modified Program, or a modification incorporated within the Program or a Modified Program constitutes direct or contributory patent infringement, then any patent licenses granted to you under this License for the Program or any such Modified Program shall terminate as of the date such litigation is filed.\nCONDITIONS TO THE RIGHT TO DISTRIBUTE 3.1. Notices. If you Distribute the Program or a Modified Program in any form, you must also provide to the recipient: 3.1.1. a copy of this License; and 3.1.2. for Modified Programs, prominent notices identifying the portions of the Modified Program that have been modified, stating that you have modified the Program. 3.2. Attribution. Except as otherwise expressly permitted under this License, you must keep intact, and you may not modify or remove, any notices, disclaimers, or attributions included in or provided with the Program. In addition, you must also include a prominent hypertext link back to NanoString’s website at www.nanostring.com. 3.3. License. You may only Distribute the Program or the Modified Program under the terms of this License (or any later version, at your election). You may not offer or impose any additional or different terms or conditions that, or take any measures to, restrict the exercise of the rights granted under this License.\nNO REPRESENTATIONS OR WARRANTIES; LIMITATIONS OF LIABILITY 4.1. Disclaimer. UNLESS OTHERWISE AGREED BY LICENSOR IN WRITING, TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, LICENSOR OFFERS THE PROGRAM AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND WITH REGARD TO THE PROGRAM, WHETHER EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT. THE LICENSOR DOES NOT REPRESENT OR WARRANT THAT THE PROGRAM WILL BE ERROR FREE AND DOES NOT PROMISE THAT ANY SUCH ERRORS WILL BE CORRECTED. SOME JURISDICTIONS DO NOT ALLOW FOR THE EXCLUSION OF IMPLIED WARRANTIES, SO THE FOREGOING MAY NOT APPLY TO YOU. 4.2. Limitation of Liability. TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT WILL THE LICENSOR OR NANOSTRING BE LIABLE TO YOU UNDER ANY LEGAL THEORY FOR ANY DAMAGES OF ANY KIND, INCLUDING ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF OR RELATED TO THE PROGRAM OR USE THEREOF, EVEN IF LICENSOR OR NANOSTRING HAS BEEN ADVISED OF THE POSSIBILITY OR LIKELIHOOD OF SUCH DAMAGES.\nMISCELLANEOUS 5.1. Right to Enforce. NanoString is an express third-party beneficiary of this License and will be entitled to enforce the provisions of this License as if it were a party hereto. 5.2. Waiver; Amendment. No term or provision hereof will be considered waived by the Licensor, and no breach excused by Licensor, unless such waiver or consent is in writing and signed by an authorized representative of Licensor. The waiver by Licensor of, or consent by Licensor to, a breach of any provision of this License by the Licensee, will not constitute, operate or be construed as a waiver of, consent to, or excuse of any other or subsequent breach by Licensee. This License may be amended or modified only by an agreement in writing signed by an authorized representative of each of Licensor and Licensee."
  },
  {
    "objectID": "license.html#license",
    "href": "license.html#license",
    "title": "Blog",
    "section": "",
    "text": "NanoString Technologies, Inc. Software License Agreement for Non-Commercial Use\nBy downloading, installing, accessing, modifying or otherwise making use of the Program (defined below), you agree to be bound by the terms and conditions of this Software License Agreement for Non-Commercial Use (this “License”).\n\nDEFINITIONS 1.1. “Affiliate” means, with respect to an individual or entity, another individual or entity: (i) on whose behalf such individual or entity is acting, or (ii) that exercises control, is controlled by, or is under common control with such individual or entity. For the purposes of this definition, the term “control” means the right, whether by ownership, exercise of voting rights, contract, or otherwise, to direct the actions of an individual or entity. 1.2. “Distribute” means to distribute, share, make available, or otherwise provide the Program or Modified Program, as applicable, or access thereto (including via a computer network) to any third party. 1.3. “Licensor” means the individual or entity licensing the rights granted in this License. 1.4. “Licensee” or “you” means the individual or entity receiving or exercising the rights granted under this License, provided that the individual or entity is not a NanoString Competitor. 1.5. “Non-Commercial Use” means any use where profit or other commercial benefit is not a direct or indirect motive or intended result. 1.6. “Modified Program” means a derivative work of, or a work that is based on, uses or incorporates, the Program (whether or not in combination with other works, materials or content). 1.7. “NanoString” means NanoString Technologies, Inc. 1.8. “NanoString Competitor” means any individual or entity that directly or indirectly competes with NanoString or any of NanoString’s Affiliates or whose Affiliate directly or indirectly competes with NanoString or any of NanoString’s Affiliates. 1.9. “Program” means the copyrightable work of authorship, program, code, or software licensed under this License.\nLICENSE 2.1. Grant. Subject to the terms and conditions of this License, Licensor hereby grants to Licensee a worldwide, royalty-free, non-exclusive, revocable license to: (a) use, Distribute, and reproduce the Program, and (b) use, create, Distribute, and reproduce Modified Programs, in each case, solely for your internal, Non-Commercial Use. No rights are granted to NanoString Competitors. 2.2. No Endorsement. Nothing in this License may be construed as permission to assert or imply that Licensor, NanoString, or other contributors to the Program sponsors, endorses, or is otherwise connected with the Licensee or the entity or institution that Licensee represents. 2.3. Trademarks. Trademark rights are not licensed to you under this License. 2.4. Grant of Patent License. Subject to the terms and conditions of this License, NanoString hereby grants to you a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, import, and otherwise transfer the Program, where such license applies only to those patent claims licensable by NanoString that are necessarily infringed by Licensee alone or by combination of its modification(s) to the Program or Modified Program to which such modification(s) was submitted. If you institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program, Modified Program, or a modification incorporated within the Program or a Modified Program constitutes direct or contributory patent infringement, then any patent licenses granted to you under this License for the Program or any such Modified Program shall terminate as of the date such litigation is filed.\nCONDITIONS TO THE RIGHT TO DISTRIBUTE 3.1. Notices. If you Distribute the Program or a Modified Program in any form, you must also provide to the recipient: 3.1.1. a copy of this License; and 3.1.2. for Modified Programs, prominent notices identifying the portions of the Modified Program that have been modified, stating that you have modified the Program. 3.2. Attribution. Except as otherwise expressly permitted under this License, you must keep intact, and you may not modify or remove, any notices, disclaimers, or attributions included in or provided with the Program. In addition, you must also include a prominent hypertext link back to NanoString’s website at www.nanostring.com. 3.3. License. You may only Distribute the Program or the Modified Program under the terms of this License (or any later version, at your election). You may not offer or impose any additional or different terms or conditions that, or take any measures to, restrict the exercise of the rights granted under this License.\nNO REPRESENTATIONS OR WARRANTIES; LIMITATIONS OF LIABILITY 4.1. Disclaimer. UNLESS OTHERWISE AGREED BY LICENSOR IN WRITING, TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, LICENSOR OFFERS THE PROGRAM AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND WITH REGARD TO THE PROGRAM, WHETHER EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT. THE LICENSOR DOES NOT REPRESENT OR WARRANT THAT THE PROGRAM WILL BE ERROR FREE AND DOES NOT PROMISE THAT ANY SUCH ERRORS WILL BE CORRECTED. SOME JURISDICTIONS DO NOT ALLOW FOR THE EXCLUSION OF IMPLIED WARRANTIES, SO THE FOREGOING MAY NOT APPLY TO YOU. 4.2. Limitation of Liability. TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT WILL THE LICENSOR OR NANOSTRING BE LIABLE TO YOU UNDER ANY LEGAL THEORY FOR ANY DAMAGES OF ANY KIND, INCLUDING ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF OR RELATED TO THE PROGRAM OR USE THEREOF, EVEN IF LICENSOR OR NANOSTRING HAS BEEN ADVISED OF THE POSSIBILITY OR LIKELIHOOD OF SUCH DAMAGES.\nMISCELLANEOUS 5.1. Right to Enforce. NanoString is an express third-party beneficiary of this License and will be entitled to enforce the provisions of this License as if it were a party hereto. 5.2. Waiver; Amendment. No term or provision hereof will be considered waived by the Licensor, and no breach excused by Licensor, unless such waiver or consent is in writing and signed by an authorized representative of Licensor. The waiver by Licensor of, or consent by Licensor to, a breach of any provision of this License by the Licensee, will not constitute, operate or be construed as a waiver of, consent to, or excuse of any other or subsequent breach by Licensee. This License may be amended or modified only by an agreement in writing signed by an authorized representative of each of Licensor and Licensee."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CosMx Analysis Scratch Space",
    "section": "",
    "text": "Under construction\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nApr 12, 2024\n\n\nEvelyn Metzger\n\n\n\n\n\n\n\n\n\n\n\n\nThe spatial algorithms zoo: recommended algorithms and efficient code\n\n\n\n\n\n\nalgorithms\n\n\n\n\n\n\n\n\n\nMar 20, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nCell typing: what we’ve found to work\n\n\n\n\n\n\ncell typing\n\n\n\n\n\n\n\n\n\nMar 12, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nOn the use of marker genes\n\n\n\n\n\n\ncell typing\n\n\n\n\n\n\n\n\n\nMar 12, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nBig datasets: strategies for memory-efficient analysis\n\n\n\n\n\n\nbig data\n\n\n\n\n\n\n\n\n\nMar 4, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nQC and normalization of RNA data\n\n\n\n\n\n\nquality control\n\n\nnormalization\n\n\npre-processing\n\n\n\n\n\n\n\n\n\nJan 29, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions for condensing FOVs and tissues to minimize whitespace\n\n\n\n\n\n\nvisualization\n\n\n\n\n\n\n\n\n\nJan 26, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nVisualize cellular neighborhood in gallery mode\n\n\n\n\n\n\nvisualization\n\n\nnapari\n\n\n\n\n\n\n\n\n\nJan 24, 2024\n\n\nLidan Wu, Patrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nThe impact of segmentation error on differential expression analyses\n\n\n\n\n\n\nsegmentation\n\n\n\n\n\n\n\n\n\nJan 24, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nWhat is high-plex spatial transcriptomics for?\n\n\n\n\n\n\noverview\n\n\n\n\n\n\n\n\n\nJan 5, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nInferring cell polygons from transcript locations\n\n\n\n\n\n\nvisualization\n\n\n\n\n\n\n\n\n\nJan 5, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/spatial-algorithm-zoo/index.html",
    "href": "posts/spatial-algorithm-zoo/index.html",
    "title": "The spatial algorithms zoo: recommended algorithms and efficient code",
    "section": "",
    "text": "Spatial statistics is a well-developed field, with deep statistical methodology and highly efficient open-source tools. In CosMx data, where a single study can contain millions of cells, computational efficiency is vital. Here we recommend some toolkits we’ve found useful:\n\n\n\nFast nearest-neighbors search\nMeasuring a gene’s spatial autocorrelation\nMeasuring spatial correlation between two genes\nCounting occurrences within cell neighborhoods\n\n\n\n\n\n\n\nneighbors &lt;- FNN::get.knnx(data = xy, # 2-column matrix of xy locations\n                           query = xy, \n                           k = 50)\n# returns 2 outputs: a matrix of each cell's nearest neighbor indices (including itself),\n#  and a matrix of distances to these neighbors.\n\n(This also works for neighbors in expression space - just input the top 20 PCs instead of xy locations.)\n\n\n\nSee the function nearestNeighborGraph in the Insitucor package\n\n# xy is a 2-column matrix of xy locations\nneighbors &lt;- InSituCor:::nearestNeighborGraph(x = xy[, 1], y = xy[, 2], n=50)\n\nNote this matrix is populated by distances, not by simple 1/0 values.\n\n\n\nSee the function radiusBasedGraph in the Insitucor package\n\n# xy is a 2-column matrix of xy locations\nneighbors &lt;- InSituCor:::radiusBasedGraph(x = xy[, 1], y = xy[, 2], R = 0.1)\n\nNote this matrix is populated by distances, not by simple 1/0 values.\n\n\n\n\nOur goal here is to measure how much a gene’s expression depends on spatial location. Genes with strong spatial dependence are presumably more interesting, deserving human attention. A much-less-than-comprehensive list of methods is below.\nMethods:\n\nMoran’s I statistic: This is a time-honored method in spatial statistics, published in 1950. Using the analytical rather than the permutation p-value speeds it up greatly, and we find their performance to be similar.\nSpatialDE: the first attempt to measure spatial autocorrelation in spatial transcriptomics. Can be slow.\nMaxspin: A more recent method using machine learning and information theory to get performance improvements. Can be slow.\nSPARK-X: Runs at speed similar to Moran’s I.\n\n\n\n\nWhen two or more genes are spatially correlated it can be of high biological interest. These genes might regulate each other via cell-cell communication, or they could be jointly regulated by some latent variable in the microenvironment.\nMethods for measuring spatial correlation between genes include:\n\nLee’s L: another spatial statistics classic.\nSpatialDE\n\nHowever, we have found methods like the above to be unsatisfying, since genes with cell-type-specific expression end up sharing strong spatial correlations. E.g. CD19 and MS4A1 are expressed mainly by B-cells, so if B-cells are spatially clustered, then these genes will be spatially correlated, but for biologically trivial reasons. To isolate more interesting spatial correlations, we developed: - InSituCor. This is our recommended approach. It can analyze hundreds of thousands of cells and thousands of genes in minutes.\n\n\n\nAnalysts will often want to score cells for how often something occurs in their neighborhoods. For example, you might want to know how many T-cell neighbors each cell has, or how many transcripts of a gene surround it.\nThe below code demonstrates how to use the spatstat::marktable function to do this.\n\n# \"xy\"\" is a 2-column matrix of cell locations\n# \"clust\"\" is a vector of cell type assignments\n# create a point process object:\npp &lt;- spatstat.geom::ppp(xy[, 1], xy[, 2], xrange = range(xy[, 1]), yrange = range(xy[, 2]))\nmarks(pp) &lt;- clust\nmarks(pp) &lt;- as.factor(marks(pp))\n# count neighbors of each db cluster:\nmt05 &lt;- spatstat::marktable(X = pp, R = 0.05, N = NULL, exclude=TRUE, collapse=FALSE)\nrownames(mt05) &lt;- names(which(use))"
  },
  {
    "objectID": "posts/spatial-algorithm-zoo/index.html#table-of-contents",
    "href": "posts/spatial-algorithm-zoo/index.html#table-of-contents",
    "title": "The spatial algorithms zoo: recommended algorithms and efficient code",
    "section": "",
    "text": "Fast nearest-neighbors search\nMeasuring a gene’s spatial autocorrelation\nMeasuring spatial correlation between two genes\nCounting occurrences within cell neighborhoods"
  },
  {
    "objectID": "posts/spatial-algorithm-zoo/index.html#fast-nearest-neighbors-search",
    "href": "posts/spatial-algorithm-zoo/index.html#fast-nearest-neighbors-search",
    "title": "The spatial algorithms zoo: recommended algorithms and efficient code",
    "section": "",
    "text": "neighbors &lt;- FNN::get.knnx(data = xy, # 2-column matrix of xy locations\n                           query = xy, \n                           k = 50)\n# returns 2 outputs: a matrix of each cell's nearest neighbor indices (including itself),\n#  and a matrix of distances to these neighbors.\n\n(This also works for neighbors in expression space - just input the top 20 PCs instead of xy locations.)\n\n\n\nSee the function nearestNeighborGraph in the Insitucor package\n\n# xy is a 2-column matrix of xy locations\nneighbors &lt;- InSituCor:::nearestNeighborGraph(x = xy[, 1], y = xy[, 2], n=50)\n\nNote this matrix is populated by distances, not by simple 1/0 values.\n\n\n\nSee the function radiusBasedGraph in the Insitucor package\n\n# xy is a 2-column matrix of xy locations\nneighbors &lt;- InSituCor:::radiusBasedGraph(x = xy[, 1], y = xy[, 2], R = 0.1)\n\nNote this matrix is populated by distances, not by simple 1/0 values."
  },
  {
    "objectID": "posts/spatial-algorithm-zoo/index.html#measuring-a-genes-spatial-autocorrelation",
    "href": "posts/spatial-algorithm-zoo/index.html#measuring-a-genes-spatial-autocorrelation",
    "title": "The spatial algorithms zoo: recommended algorithms and efficient code",
    "section": "",
    "text": "Our goal here is to measure how much a gene’s expression depends on spatial location. Genes with strong spatial dependence are presumably more interesting, deserving human attention. A much-less-than-comprehensive list of methods is below.\nMethods:\n\nMoran’s I statistic: This is a time-honored method in spatial statistics, published in 1950. Using the analytical rather than the permutation p-value speeds it up greatly, and we find their performance to be similar.\nSpatialDE: the first attempt to measure spatial autocorrelation in spatial transcriptomics. Can be slow.\nMaxspin: A more recent method using machine learning and information theory to get performance improvements. Can be slow.\nSPARK-X: Runs at speed similar to Moran’s I."
  },
  {
    "objectID": "posts/spatial-algorithm-zoo/index.html#measuring-spatial-correlation-between-two-genes",
    "href": "posts/spatial-algorithm-zoo/index.html#measuring-spatial-correlation-between-two-genes",
    "title": "The spatial algorithms zoo: recommended algorithms and efficient code",
    "section": "",
    "text": "When two or more genes are spatially correlated it can be of high biological interest. These genes might regulate each other via cell-cell communication, or they could be jointly regulated by some latent variable in the microenvironment.\nMethods for measuring spatial correlation between genes include:\n\nLee’s L: another spatial statistics classic.\nSpatialDE\n\nHowever, we have found methods like the above to be unsatisfying, since genes with cell-type-specific expression end up sharing strong spatial correlations. E.g. CD19 and MS4A1 are expressed mainly by B-cells, so if B-cells are spatially clustered, then these genes will be spatially correlated, but for biologically trivial reasons. To isolate more interesting spatial correlations, we developed: - InSituCor. This is our recommended approach. It can analyze hundreds of thousands of cells and thousands of genes in minutes."
  },
  {
    "objectID": "posts/spatial-algorithm-zoo/index.html#counting-occurrences-within-cell-neighborhoods",
    "href": "posts/spatial-algorithm-zoo/index.html#counting-occurrences-within-cell-neighborhoods",
    "title": "The spatial algorithms zoo: recommended algorithms and efficient code",
    "section": "",
    "text": "Analysts will often want to score cells for how often something occurs in their neighborhoods. For example, you might want to know how many T-cell neighbors each cell has, or how many transcripts of a gene surround it.\nThe below code demonstrates how to use the spatstat::marktable function to do this.\n\n# \"xy\"\" is a 2-column matrix of cell locations\n# \"clust\"\" is a vector of cell type assignments\n# create a point process object:\npp &lt;- spatstat.geom::ppp(xy[, 1], xy[, 2], xrange = range(xy[, 1]), yrange = range(xy[, 2]))\nmarks(pp) &lt;- clust\nmarks(pp) &lt;- as.factor(marks(pp))\n# count neighbors of each db cluster:\nmt05 &lt;- spatstat::marktable(X = pp, R = 0.05, N = NULL, exclude=TRUE, collapse=FALSE)\nrownames(mt05) &lt;- names(which(use))"
  },
  {
    "objectID": "posts/normalization/index.html#qc",
    "href": "posts/normalization/index.html#qc",
    "title": "QC and normalization of RNA data",
    "section": "QC",
    "text": "QC\nQC in CosMx is motivated by known error modes. Here’s a list of major things that can go wrong:\n\nA cell might be undersampled, leading to excessively low counts (Either only a tip of it is in the slide, or detection efficiency is poor within it.) Solution: remove the cell.\nA cell might suffer extremely high background, either due to intrinsic tissue stickiness (e.g. associated with necrosis) or due to optical artifacts. Solution: remove the cell.\nErrors in cell segmentation might assign multiple cells to the same “cell”. Solution: remove these multiplets.\nA FOV might have low counts overall. This can be caused by imaging trouble, tissue peeling, and probably other causes. Solution: remove FOVs with low quality data. (Removing low quality cells isn’t good enough. If a bad FOV has half its cells removed, the spatial pattern implied by the remaining cells, those lucky enough to survive the cell QC, won’t be representative.)\nA FOV’s expression profile can be distorted by image registration errors or by imaging artifacts, e.g. fluorescence hiding spots of one color. These FOVs can be analyzable if you’re careful, but given the uncertainty they pose it’s usually best to remove them.\n\nQC logic would then proceed as follows:\n\nRemove cells with too few counts. For our 1000plex assay, we use a pretty generous threshold of 20 counts. A higher threshold would be reasonable.\n\n\n# counts is the matrix of raw expression profiles, cells in rows, genes in columns\ntotalcounts &lt;- Matrix::rowSums(counts)  \ndrop &lt;- totalcounts &lt; 20\n\n\nRemove cells with high outlier areas. You can use Grubb’s test to detect outliers, or you can draw a histogram of cell areas and choose a cutoff on your own.\nRemove FOVs with poor counts. AtoMx removes FOVs based on their mean count per cell, or by a user-specified quantile of counts per cell. Filtering on % of cells flagged by the above criteria would also be reasonable.\nFlag FOVs with distorted expression profiles. AtoMx now flags FOVs where z-stack registration is highly unstable, but older runs won’t benefit from this update, and other effects, namely background fluorescence, can still distort FOV expression profiles. Unfortunately, there’s no easy automated way to flag outlier FOVs (yet). Fortunately, they do tend to stand out in spatial analyses. If you e.g. plot cell typing results in space, or plot spatial clustering results in space, outlier FOVs stand out strongly. They can then be manually flagged and removed."
  },
  {
    "objectID": "posts/normalization/index.html#normalization",
    "href": "posts/normalization/index.html#normalization",
    "title": "QC and normalization of RNA data",
    "section": "Normalization",
    "text": "Normalization\nUnlike scRNA-seq data, where cells tend to have somewhat consistent expression levels, spatial platforms vary widely in how much of a cell’s RNA they detect. Normalizing out this effect is important for some analyses. We make the reasonable assumption that a cell’s detection efficiency is well-estimated by its total counts, which implies we can scale each cell’s profile by its total counts:\n\n# counts is the matrix of raw expression profiles, cells in rows, genes in columns\ntotalcounts &lt;- Matrix::rowSums(counts)  \nnorm &lt;- sweep(counts, 1, pmax(totalcounts, 20), \"/\")\n\n…note the pmax(totalcounts, 20) term in the above. This puts a floor on how much we’ll up-scale a cell. This prevents us from taking cells with very few counts and drastically scaling them up, which gives them undeserved highly-distinct expression profiles.\n(Note: some authors have pointed out that there’s information to be had in a cell’s total counts. For example, cancer cells tend to have high overall RNA expression. When we normalize, we lose this information. But we’ve usually found that a small price to pay to control the variability in total counts that arises from unwanted technical sources.)"
  },
  {
    "objectID": "posts/normalization/index.html#other-transformations",
    "href": "posts/normalization/index.html#other-transformations",
    "title": "QC and normalization of RNA data",
    "section": "Other transformations",
    "text": "Other transformations\nWe generally do not perform non-linear transformations on our data.\nException: UMAPs often look better when drawn from log- and sqrt-transformed data or from Pearson residuals. Pearson residuals are problematic for big datasets, however, since they convert your data from a sparse matrix to a dense matrix."
  },
  {
    "objectID": "posts/deriving-cell-polygons-from-transcript-locations/index.html",
    "href": "posts/deriving-cell-polygons-from-transcript-locations/index.html",
    "title": "Inferring cell polygons from transcript locations",
    "section": "",
    "text": "A complete CosMx dataset will contain polygonal boundaries for each cell for use in plotting. In practice, especially with earlier datasets or with datasets passed between collaborators, this data can be missing. We’ve created a toolkit for deriving these polygons from cells’ transcript locations. (Note: we are not performing cell segmentation here, just drawing boundaries around transcripts already assigned to cells.)\nYou can find the package here.\nPlotting cells as polygons looks better in zoomed-in views, and it allows for plotting of individual transcripts as in the below:"
  },
  {
    "objectID": "posts/deriving-cell-polygons-from-transcript-locations/index.html#deriving-cell-polygons-for-plotting",
    "href": "posts/deriving-cell-polygons-from-transcript-locations/index.html#deriving-cell-polygons-for-plotting",
    "title": "Inferring cell polygons from transcript locations",
    "section": "",
    "text": "A complete CosMx dataset will contain polygonal boundaries for each cell for use in plotting. In practice, especially with earlier datasets or with datasets passed between collaborators, this data can be missing. We’ve created a toolkit for deriving these polygons from cells’ transcript locations. (Note: we are not performing cell segmentation here, just drawing boundaries around transcripts already assigned to cells.)\nYou can find the package here.\nPlotting cells as polygons looks better in zoomed-in views, and it allows for plotting of individual transcripts as in the below:"
  },
  {
    "objectID": "posts/visuals-reduce-whitespace/index.html",
    "href": "posts/visuals-reduce-whitespace/index.html",
    "title": "Functions for condensing FOVs and tissues to minimize whitespace",
    "section": "",
    "text": "Minimizing whitespace while plotting cells in xy space is a constant challenge. A single tissue will often have discontinuous FOVs, and aligning multiple tissues in a sensible way can be onerous.\nHere, for example, are FOVs collected from core needle biopsies, where the cells can barely be seen against the vast expanse of white space.\n\nAs a partial solution, see the function consenseXY(), provided here.\nThe main wrapper function contains an algorithm for pulling together FOVs from the same tissue, and an algorithm for tiling tissues across a plot.\nHere’s a toy example of FOV groups from two tissues before and after the algorithm (color denotes tissue ID):\n\nIt’s not perfect, but it’s an improvement on the original spacing with no thought or manual labor.\nWarning: the FOV condensing code is inefficiently written and takes longer than it should, though it’s still faster than working by hand."
  },
  {
    "objectID": "posts/visuals-reduce-whitespace/index.html#condensing-cells-in-xy-space-for-better-plotting",
    "href": "posts/visuals-reduce-whitespace/index.html#condensing-cells-in-xy-space-for-better-plotting",
    "title": "Functions for condensing FOVs and tissues to minimize whitespace",
    "section": "",
    "text": "Minimizing whitespace while plotting cells in xy space is a constant challenge. A single tissue will often have discontinuous FOVs, and aligning multiple tissues in a sensible way can be onerous.\nHere, for example, are FOVs collected from core needle biopsies, where the cells can barely be seen against the vast expanse of white space.\n\nAs a partial solution, see the function consenseXY(), provided here.\nThe main wrapper function contains an algorithm for pulling together FOVs from the same tissue, and an algorithm for tiling tissues across a plot.\nHere’s a toy example of FOV groups from two tissues before and after the algorithm (color denotes tissue ID):\n\nIt’s not perfect, but it’s an improvement on the original spacing with no thought or manual labor.\nWarning: the FOV condensing code is inefficiently written and takes longer than it should, though it’s still faster than working by hand."
  },
  {
    "objectID": "posts/cell-typing-basics/index.html",
    "href": "posts/cell-typing-basics/index.html",
    "title": "Cell typing: what we’ve found to work",
    "section": "",
    "text": "We cell type most studies using one of the following approaches:\n\nInsitutype\nLeiden clustering\nSeurat’s label transfer algorithm\n\n\n\nWe created Insitutype for cell typing in CosMx data. It can perform unsupervised clustering, supervised cell typing if given a matrix of reference profiles, or semi-supervised cell typing to call pre-defined cell types alongside new clusters. Insitutype’s models the evidence provided by every gene in a cell’s profile; this makes it excel in cells / datasets with less signal.\nInsitutype resources:\n\nhttps://github.com/Nanostring-Biostats/insitutype (see the FAQs.md for detailed advice)\nhttps://www.biorxiv.org/content/10.1101/2022.10.19.512902v1\nA collection of cell profile reference matrices will be posted on https://github.com/Nanostring-Biostats in early 2024.\n\n\n\n\nA single-cell clustering mainstay. Unsupervised clustering only. Often run from principal components of the expression data. Seurat, Giotto and igraph all have convenient implementations.\n\n\n\nIf a full scRNA-seq reference dataset is available, and if no new cell types are expected in the CosMx data, then these algorithms can work well. We have found Seurat’s implementation to work in some studies.\n\n\n\n\n\nLeiden clustering and UMAP tend to see the world the same way - that is, they’re both based on networks connecting similar cells. This makes Leiden results agree well with the UMAP, whether or not they are truly more accurate. In other words, don’t take the UMAP as an impartial arbiter of cell typing truth.\nInsitutype tends to be the most resistant to batch effects; methods that rely on PCs tend to be the most easily fooled by batch effects.\nMost studies require careful scrutiny of cell typing results. Often clusters have to be merged or subclustered before results are satisfactory. See the Insitutype FAQs.md for a detailed discussion of how to QC & refine cell typing results. Many of these QCs are useful for results of other methods."
  },
  {
    "objectID": "posts/cell-typing-basics/index.html#choice-of-cell-typing-algorithm",
    "href": "posts/cell-typing-basics/index.html#choice-of-cell-typing-algorithm",
    "title": "Cell typing: what we’ve found to work",
    "section": "",
    "text": "We cell type most studies using one of the following approaches:\n\nInsitutype\nLeiden clustering\nSeurat’s label transfer algorithm\n\n\n\nWe created Insitutype for cell typing in CosMx data. It can perform unsupervised clustering, supervised cell typing if given a matrix of reference profiles, or semi-supervised cell typing to call pre-defined cell types alongside new clusters. Insitutype’s models the evidence provided by every gene in a cell’s profile; this makes it excel in cells / datasets with less signal.\nInsitutype resources:\n\nhttps://github.com/Nanostring-Biostats/insitutype (see the FAQs.md for detailed advice)\nhttps://www.biorxiv.org/content/10.1101/2022.10.19.512902v1\nA collection of cell profile reference matrices will be posted on https://github.com/Nanostring-Biostats in early 2024.\n\n\n\n\nA single-cell clustering mainstay. Unsupervised clustering only. Often run from principal components of the expression data. Seurat, Giotto and igraph all have convenient implementations.\n\n\n\nIf a full scRNA-seq reference dataset is available, and if no new cell types are expected in the CosMx data, then these algorithms can work well. We have found Seurat’s implementation to work in some studies."
  },
  {
    "objectID": "posts/cell-typing-basics/index.html#general-cell-typing-notes",
    "href": "posts/cell-typing-basics/index.html#general-cell-typing-notes",
    "title": "Cell typing: what we’ve found to work",
    "section": "",
    "text": "Leiden clustering and UMAP tend to see the world the same way - that is, they’re both based on networks connecting similar cells. This makes Leiden results agree well with the UMAP, whether or not they are truly more accurate. In other words, don’t take the UMAP as an impartial arbiter of cell typing truth.\nInsitutype tends to be the most resistant to batch effects; methods that rely on PCs tend to be the most easily fooled by batch effects.\nMost studies require careful scrutiny of cell typing results. Often clusters have to be merged or subclustered before results are satisfactory. See the Insitutype FAQs.md for a detailed discussion of how to QC & refine cell typing results. Many of these QCs are useful for results of other methods."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "CosMx Analysis Scratch Space",
    "section": "",
    "text": "This repo is here to accelerate analysis of CosMx datasets. It contains code and writeups addressing challenges we’ve faced in analyzing CosMx data. After dozens of analyses, we have developed a sense of what works and what doesn’t, and we have developed (sometimes partial) solutions for many frequent problems."
  },
  {
    "objectID": "about.html#data-formats",
    "href": "about.html#data-formats",
    "title": "CosMx Analysis Scratch Space",
    "section": "Data Formats",
    "text": "Data Formats\n\nFile structure output by the AtoMx export module\nConverting between data formats: AtoMx flat files, Seurat, squidpy"
  },
  {
    "objectID": "about.html#analysis-strategies",
    "href": "about.html#analysis-strategies",
    "title": "CosMx Analysis Scratch Space",
    "section": "Analysis Strategies",
    "text": "Analysis Strategies\n\nWhat is spatial data for?\nQC and normalization of RNA data\nBatch correction\nThe spatial algorithms zoo: recommended algorithms and efficient code\nA generally satisfying set of UMAP parameters for CosMx data\nThe impact of segmentation error on differential expression analyses\nQuick & comprehensive searches for interesting trends with “Everything vs. everything DE”\nSmoothing single cell gene expression for enhanced plotting\nApproaches to ligand-receptor analysis\nBig datasets: strategies for memory-efficient analysis\nlots without excessive file sizes\nFunctions for condensing FOVs and tissues to minimize whitespace\nInferring cell polygons from transcript locations\n(For fun) Spatial transcriptomics plots in stained glass\nVisualization of cellular neighborhood in gallery mode"
  },
  {
    "objectID": "about.html#cell-typing",
    "href": "about.html#cell-typing",
    "title": "CosMx Analysis Scratch Space",
    "section": "Cell typing",
    "text": "Cell typing\n\nCell typing: what we’ve found to work\nOn the use of marker genes\nHierarchical (“plinko”) cell typing\nCell typing with smoothed marker genes\nIntegrating spatial information and/or cell images into existing cell typing results"
  },
  {
    "objectID": "about.html#viewing-cosmx-data-with-napari",
    "href": "about.html#viewing-cosmx-data-with-napari",
    "title": "CosMx Analysis Scratch Space",
    "section": "Viewing CosMx data with Napari",
    "text": "Viewing CosMx data with Napari\n\nIntro: using Napari to view and analyze CosMx data\nCreating Napari-ready files from AtoMx exports\nNapari-CosMx plugin basics\nAdvanced plugin tips: creating regions of interests to select cells\nAdvanced plugin tips: reproducibility of images and creating animations"
  },
  {
    "objectID": "about.html#tissue-specific-solutions",
    "href": "about.html#tissue-specific-solutions",
    "title": "CosMx Analysis Scratch Space",
    "section": "Tissue-specific solutions",
    "text": "Tissue-specific solutions\n\nA workflow for kidney samples: cell typing and glomerulus definitions\nScoring brain cells for distance to plaques"
  },
  {
    "objectID": "how-to-contribute.html",
    "href": "how-to-contribute.html",
    "title": "Blog",
    "section": "",
    "text": "This section is currently under construction. Please check back later."
  },
  {
    "objectID": "how-to-contribute.html#how-to-contribute",
    "href": "how-to-contribute.html#how-to-contribute",
    "title": "Blog",
    "section": "",
    "text": "This section is currently under construction. Please check back later."
  },
  {
    "objectID": "posts/high-plex-spatial/index.html",
    "href": "posts/high-plex-spatial/index.html",
    "title": "What is high-plex spatial transcriptomics for?",
    "section": "",
    "text": "What is high-plex spatial transcriptomics for?\nHigh-plex single cell spatial transcriptomics data is a little awe-inspiring: even a perfunctory analysis of a single run produces a terabyte of data, gorgeous images, and spatial relationships from the scale of centimeters to micrometers that you could spend weeks exploring.\nBut ultimately, you don’t need amazing images, you need answers to biological questions. Here I’ll lay out questions typically asked with spatial transcriptomics, and I’ll suggest a more expansive approach that reveals spatial single-cell data to be perhaps the most productive question-posing machine in molecular biology.\nData analysis begins with two fundamental pieces: a matrix of all cells’ gene expression, and their spatial locations: \nAs with any single cell dataset, we begin by using the gene expression matrix to call cell types. Then, simply coloring our spatial map by cell type, we obtain an intricate picture of tissue structure.\n\nEven this simplistic analysis is valuable: most experts examining these plots come away with new insights and new questions.\nQuestions answered with cell type + location:\n\nHow is each immune cell type spread through this tumor? Where are the inflammatory vs. the suppressive macrophages trafficking?\nDo we see more memory T-cell invasion in post-treatment samples?\nWhat immune cell types tend to physically interact with each other?\n\nMost early analyses of spatial transcriptomic data stop here. They wrap questions like the above in formal statistics (“spatial clustering” / “niche analysis”, “cell proximity analysis”), and publish what is usually already a compelling story. But if we take this analysis just a little farther, we can begin to ask a staggering number of questions. The power of this data isn’t its ability to get single cell expression profiles, nor its ability to describe spatial variation: it’s the ability to do both of these at the same time. By simultaneously measuring single cells’ phenotypes (gene expression) and environments (the phenotypes of surrounding cells), we can interrogate how phenotype responds to environment. What can we say about a cell’s environment? Consider the below closeup of a PDAC tumor. “T-cell 1” is in a lymphoid structure, surrounded by B-cells and endothelial cells. These cells are expressing certain levels of ligands that bind receptors on T-cells. In contrast, “T-cell 2” has invaded into the tumor bed and is mainly surrounded by tumor cells, plus a few macrophages, and these cells are signaling the T-cell with a different set of genes.\n\nIn short, we can trivially derive over 1000 variables describing each cell’s environment. And now, for every cell type, we can measure how every gene responds to every environmental variable. This amounts to roughly 20 * 1000 * 1000 = 20 million questions. Or, in a study across multiple tissues, we might ask these 20 million questions separately for each tissue. (Note that in a lower-plex technology, where a panel of ~300 genes might be devoted almost entirely to cell typing, the number of interesting questions to be asked drops precipitously.)\nIn short, a standard analysis can lead to millions of hypothesis tests. Single-cell data without spatial information, and spatial data at larger-than-single-cell resolution, can’t come close to this.\nQuestions on how phenotype responds to environment:\n\nHow do tumor cells modulate gene expression in the face of T-cell attack?\nHow do macrophages in the stroma differ from macrophages in the tumor interior?\nWhat genes do T-cells express when exposed to inflammatory cytokines?"
  },
  {
    "objectID": "posts/on-cell-typing-with-marker-genes/index.html",
    "href": "posts/on-cell-typing-with-marker-genes/index.html",
    "title": "On the use of marker genes",
    "section": "",
    "text": "On cell typing with marker genes\nOur basic recommendation is this: relying on a few marker genes alone will not produce successful cell typing.\nSpatial transcriptomics data has two features that make marker genes challenging to use.\n\nBackground: cells’ expression profiles can include two kinds of false counts: these platforms sometimes see transcripts that aren’t present (false detections), and errors in cell segmentation lead transcripts from one cell to be assigned to its neighbor. Both these phenomena lead to marker genes being counted in cells where they aren’t truly present.\nVariable signal strength / false negative detection: tissues and cells vary widely in how efficiently existing RNA molecules are read. Thus genes with low expression are easily missed in many cells.\n\nApplying the above phenomena to FOXP3, the canonical marker for Treg cells, we can envision non-Treg cells with spurious FOXP3 coming from false detections or contamination from a neighboring Treg (error mode 1 above), and we can imagine Treg cells where FOXP3 isn’t detected (error mode 2 above). A cell typing regime that applied an expression threshold to FOXP3 would be unacceptably error-prone.\nInstead of using marker genes, we recommend cell typing using most or all of cells’ expression profiles. The data for a single gene in a single cell is noisy, but the evidence from a complete expression profile is much more stable. Given clusters derived from all or most of your panel, marker genes are useful for annotating clusters. E.g., if a cluster is enriched in FOXP3, you can safely label it Tregs.\nAs an advanced approach, we have had success cell typing using smoothed expression of marker genes. We replace each cell’s observed profile with the average profile of the 20+ cells that have the most similar expression profiles to it. This essentially performs a variance-bias tradeoff: we bias a cell to look like its neighbors in expression space, but we greatly cut down the noise in the expression level. Cell typing based on marker genes in this smoothed data can be successful."
  },
  {
    "objectID": "posts/visualize-cellular-neighborhood-in-gallery-mode/index.html",
    "href": "posts/visualize-cellular-neighborhood-in-gallery-mode/index.html",
    "title": "Visualize cellular neighborhood in gallery mode",
    "section": "",
    "text": "A complete CosMx dataset will contain cell metadata, morphology/protein images and cell label results of cell segmentation. We’ve created a toolkit for visualizing the neighborhood of query cells in terms of protein staining, cell segmentation border, numeric and categorical metadata. (Note: we are not performing cell typing or cell segmetnation here, just drawing boundaries from the existing cell label/segmetnation results.)\nYou can find the package here. See the corresponding tutorial inside the package for more details.\nThe inputs required:\n\ncell metadata with unique cell_ID in format of c_[slide]_[fov]__[CellId].\nEither file path to CellStatsDir that contains per FOV level of cell label images, morphology C902 images and optional ProteinDir that contains per FOV level of protein images.\nOr file path to napari-cosmx dataset which contains stitched images for cell label, morphology and optional protein images of entire slide.\n\nThis code expects the file format output generated by CosMx Single Molecular Imager (SMI) and napari-cosMx plugin. Here are the example data/folder structure of the required input files.\n\nExample cell metadata:\n\n\n\nExample CellStatsDir and ProteinDir under raw data folder of given slide.\n\nEach FOV subfolder under CellStatsDir contains cell label images of given FOV.\n\n\n\n\nMorphology2D subfolder under CellStatsDir contains multi-channel morphology images of each FOV.\n\n\n\nEach FOV subfolder under ProteinDir contains a folder called ProteinImages, which has single-channel images for all the protein profiled for the given FOV.\n\n\n\nExample napari-cosmx dataset with stitched images: labels for cell labels, protein/[proteinName] for single-channel protein images, other folders (e.g. DNA) for single-channel morphology images.\n\n\nBelow are the example outputs of plotting query cells’ neighborhood:\n\nPlotting morphology images and cell borers of query cells’s neighborhood\n\n\n\nPlotting numeric and categorical metadata of query cells’ neighborhood"
  },
  {
    "objectID": "posts/visualize-cellular-neighborhood-in-gallery-mode/index.html#visualize-cellular-neighborhood-in-gallery-mode",
    "href": "posts/visualize-cellular-neighborhood-in-gallery-mode/index.html#visualize-cellular-neighborhood-in-gallery-mode",
    "title": "Visualize cellular neighborhood in gallery mode",
    "section": "",
    "text": "A complete CosMx dataset will contain cell metadata, morphology/protein images and cell label results of cell segmentation. We’ve created a toolkit for visualizing the neighborhood of query cells in terms of protein staining, cell segmentation border, numeric and categorical metadata. (Note: we are not performing cell typing or cell segmetnation here, just drawing boundaries from the existing cell label/segmetnation results.)\nYou can find the package here. See the corresponding tutorial inside the package for more details.\nThe inputs required:\n\ncell metadata with unique cell_ID in format of c_[slide]_[fov]__[CellId].\nEither file path to CellStatsDir that contains per FOV level of cell label images, morphology C902 images and optional ProteinDir that contains per FOV level of protein images.\nOr file path to napari-cosmx dataset which contains stitched images for cell label, morphology and optional protein images of entire slide.\n\nThis code expects the file format output generated by CosMx Single Molecular Imager (SMI) and napari-cosMx plugin. Here are the example data/folder structure of the required input files.\n\nExample cell metadata:\n\n\n\nExample CellStatsDir and ProteinDir under raw data folder of given slide.\n\nEach FOV subfolder under CellStatsDir contains cell label images of given FOV.\n\n\n\n\nMorphology2D subfolder under CellStatsDir contains multi-channel morphology images of each FOV.\n\n\n\nEach FOV subfolder under ProteinDir contains a folder called ProteinImages, which has single-channel images for all the protein profiled for the given FOV.\n\n\n\nExample napari-cosmx dataset with stitched images: labels for cell labels, protein/[proteinName] for single-channel protein images, other folders (e.g. DNA) for single-channel morphology images.\n\n\nBelow are the example outputs of plotting query cells’ neighborhood:\n\nPlotting morphology images and cell borers of query cells’s neighborhood\n\n\n\nPlotting numeric and categorical metadata of query cells’ neighborhood"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Under construction",
    "section": "",
    "text": "This site is under construction."
  },
  {
    "objectID": "posts/big-data/index.html",
    "href": "posts/big-data/index.html",
    "title": "Big datasets: strategies for memory-efficient analysis",
    "section": "",
    "text": "CosMx data can be truly huge, containing millions of cells and thousands of genes. This prevents many typical analysis strategies, including many toolkits designed for scRNA-seq data. Here we’ll discuss ways to work with big datasets.\n\n\nNo analysis method uses all your data at once. So for any given analysis, pull in only what you need. See below for a discussion of data types and how to handle them.\n\n\nCosMx data comes several varieties:\n\n\nThese are matrices of cells * genes or cells * cells, populated mainly by 0 values. Sparse matrix formats allow us to only store information for non-zero values, greatly reducing memory demands. When working with sparse matrices, try to use methods that can act on this data type.\nExamples of sparse matrices:\n\nraw counts (sparse matrix, integers)\nnorm counts (sparse, but now decimals. can round to 3 or 4 decimal places to control size a bit)\ncells’ neighbor relationships (e.g. 50 entries per cell for 50 nearest neighbors)\n\n\n\n\nSome data is inevitably dense. Ideally, only pull this data into memory when you need it.\nExamples of dense data:\n\nCell metadata. Storing as a data table is most efficient. Since this usually has dozens of variables that are unnecessary for most analyses, you can also keep in memory only the columns you need for a given analysis.\nPrincipal components. Unavoidably large. To save memory, store only the top 20-50 PCs, throwing out the information-light remaining PCs.\n\n\n\n\n\numap\nxy locations\n\n\n\n\n\nTranscript locations. This comes in an enormous data table. In most studies you’ll want to handle this in chunks, e.g. one FOV / region at a time, or one gene.\nCell polygons. Another very large file. Since you can’t resolve polygon shapes for tens of thousands of cells at once, this data is only useful for very zoomed-in plots, allowing you to only keep say thousands of cell polygons in memory at once.\n\n\n\n\n\n\nIt doesn’t take too many slides before you can no longer fit the raw count matrix into R. At this point, you’re forced to work in batches. One good approach is to run fundamental analyses - e.g. QC, normalization, dimension reduction and cell typing - one sample at a time, saving your results to disk. Then for study-wide analyzes you can load in only the data you need, e.g. xy positions and cell types, or normalized expression values from a single gene.\n\n\n\nData formats do exist for this purpose, and they’re developing rapidly. Consider:\n\nTileDB / TileDBSOMA TileDBsc\nSeuratDisk\nSeurat v5 has some functionality for switching between disk and memory, but not yet enough to support a full spatial analysis.\n\n\n\n\nLarge datasets take time to analyze, there is no way around that, but some simple computation choices can make a big impact.\nEnsure your data stays in sparse matrix format; watch out for dense coercions. The Matrix package is great to ensure sparsity.\nParallelization is your friend but be sure to understand how much data you are reading into memory in each core. While as fast as possible is always nice, hardware does have its limitations."
  },
  {
    "objectID": "posts/big-data/index.html#strategy-1-be-intentional-about-what-data-you-bring-into-memory",
    "href": "posts/big-data/index.html#strategy-1-be-intentional-about-what-data-you-bring-into-memory",
    "title": "Big datasets: strategies for memory-efficient analysis",
    "section": "",
    "text": "No analysis method uses all your data at once. So for any given analysis, pull in only what you need. See below for a discussion of data types and how to handle them.\n\n\nCosMx data comes several varieties:\n\n\nThese are matrices of cells * genes or cells * cells, populated mainly by 0 values. Sparse matrix formats allow us to only store information for non-zero values, greatly reducing memory demands. When working with sparse matrices, try to use methods that can act on this data type.\nExamples of sparse matrices:\n\nraw counts (sparse matrix, integers)\nnorm counts (sparse, but now decimals. can round to 3 or 4 decimal places to control size a bit)\ncells’ neighbor relationships (e.g. 50 entries per cell for 50 nearest neighbors)\n\n\n\n\nSome data is inevitably dense. Ideally, only pull this data into memory when you need it.\nExamples of dense data:\n\nCell metadata. Storing as a data table is most efficient. Since this usually has dozens of variables that are unnecessary for most analyses, you can also keep in memory only the columns you need for a given analysis.\nPrincipal components. Unavoidably large. To save memory, store only the top 20-50 PCs, throwing out the information-light remaining PCs.\n\n\n\n\n\numap\nxy locations\n\n\n\n\n\nTranscript locations. This comes in an enormous data table. In most studies you’ll want to handle this in chunks, e.g. one FOV / region at a time, or one gene.\nCell polygons. Another very large file. Since you can’t resolve polygon shapes for tens of thousands of cells at once, this data is only useful for very zoomed-in plots, allowing you to only keep say thousands of cell polygons in memory at once."
  },
  {
    "objectID": "posts/big-data/index.html#strategy-2-process-each-tissue-slide-separately",
    "href": "posts/big-data/index.html#strategy-2-process-each-tissue-slide-separately",
    "title": "Big datasets: strategies for memory-efficient analysis",
    "section": "",
    "text": "It doesn’t take too many slides before you can no longer fit the raw count matrix into R. At this point, you’re forced to work in batches. One good approach is to run fundamental analyses - e.g. QC, normalization, dimension reduction and cell typing - one sample at a time, saving your results to disk. Then for study-wide analyzes you can load in only the data you need, e.g. xy positions and cell types, or normalized expression values from a single gene."
  },
  {
    "objectID": "posts/big-data/index.html#strategy-3-use-data-objects-that-handle-moving-data-between-disk-and-memory",
    "href": "posts/big-data/index.html#strategy-3-use-data-objects-that-handle-moving-data-between-disk-and-memory",
    "title": "Big datasets: strategies for memory-efficient analysis",
    "section": "",
    "text": "Data formats do exist for this purpose, and they’re developing rapidly. Consider:\n\nTileDB / TileDBSOMA TileDBsc\nSeuratDisk\nSeurat v5 has some functionality for switching between disk and memory, but not yet enough to support a full spatial analysis."
  },
  {
    "objectID": "posts/big-data/index.html#strategy-4-efficient-computing",
    "href": "posts/big-data/index.html#strategy-4-efficient-computing",
    "title": "Big datasets: strategies for memory-efficient analysis",
    "section": "",
    "text": "Large datasets take time to analyze, there is no way around that, but some simple computation choices can make a big impact.\nEnsure your data stays in sparse matrix format; watch out for dense coercions. The Matrix package is great to ensure sparsity.\nParallelization is your friend but be sure to understand how much data you are reading into memory in each core. While as fast as possible is always nice, hardware does have its limitations."
  },
  {
    "objectID": "posts/segmentation-error/index.html",
    "href": "posts/segmentation-error/index.html",
    "title": "The impact of segmentation error on differential expression analyses",
    "section": "",
    "text": "Cell segmentation is always imperfect, leaving some cells’ expression profiles contaminated with transcripts properly belonging to other cells. For many analyses, this is a largely ignorable source of noise. But for differential expression (DE) analyses, it’s reliably confounding (both statistically and emotionally).\n\n\nFor an example, see the below cartoon, where a T-cell’s expression profile is contaminated with transcripts from the tumor cells surrounding it:\n\nNow say we want to compare T-cells in the tumor bed vs. T-cells in the stroma. We’ll find that T-cells in the tumor bed are enriched in genes expressed by cancer cells (e.g. keratins), and similarly, T-cells in the stroma will be enriched in genes expressed by stroma cells (e.g. collagens). In practice, spurious findings like these are often the most significant genes emerging from a DE analysis.\n\n\n\nSegmentation error can be considered a missing term in a differential expression model. Say you’re answering the above T-cell question by fitting the below model on T-cells:\nE(observed KRT9 expression) = B0 + B1  (in_tumor)*\nWhen you do this, you’re omitting an important term for contamination:\nE(observed KRT9 expression) = B0 + B1  (in_tumor) + (N_contaminating_transcripts)*\nYour model is underspecified, so its results are biased. As you measure more cells and gain statistical power, you only gain more confidence in your biased results.\n\n\n\nWe are preparing a manuscript detailing countermeasures to segmentation. Stay tuned for a link to it, or ask us for code if you can’t wait. For now, two pieces of advice:\n\nDon’t bother analyzing genes that are dominated by contamination. If you’re analyzing T-cells in tumors, then analyzing KRT9 is hopeless: T-cells barely express it, while the surrounding tumor cells will express it highly. Whatever expression you do see in T-cells will be dominated by contamination. A simple approach: if you’re e.g. analyzing T-cells, then compare each gene’s expression within T-cells to its expression in spatial neighbors of T-cells. The ratio between these numbers tells you how much of that gene’s expression in T-cells is real vs. contamination. Apply a reasonable threshold, and don’t even analyze genes with much higher expression around T-cells than inside T-cells.\nEstimate each cell’s contamination, and adjust for it in your models. Adding e.g. a term holding a gene’s expression in each cell’s neighbors achieves this well; more complex transformations of this term can be more optimal (see our upcoming paper). However, this only ameliorates, not solves, the bias from contamination. Because your estimated contamination term is a noisy approximation to true contamination, your models will estimate an attenuated effect size for the contamination term, and it won’t remove all the bias."
  },
  {
    "objectID": "posts/segmentation-error/index.html#the-problem",
    "href": "posts/segmentation-error/index.html#the-problem",
    "title": "The impact of segmentation error on differential expression analyses",
    "section": "",
    "text": "For an example, see the below cartoon, where a T-cell’s expression profile is contaminated with transcripts from the tumor cells surrounding it:\n\nNow say we want to compare T-cells in the tumor bed vs. T-cells in the stroma. We’ll find that T-cells in the tumor bed are enriched in genes expressed by cancer cells (e.g. keratins), and similarly, T-cells in the stroma will be enriched in genes expressed by stroma cells (e.g. collagens). In practice, spurious findings like these are often the most significant genes emerging from a DE analysis."
  },
  {
    "objectID": "posts/segmentation-error/index.html#how-to-think-about-segmentation-error",
    "href": "posts/segmentation-error/index.html#how-to-think-about-segmentation-error",
    "title": "The impact of segmentation error on differential expression analyses",
    "section": "",
    "text": "Segmentation error can be considered a missing term in a differential expression model. Say you’re answering the above T-cell question by fitting the below model on T-cells:\nE(observed KRT9 expression) = B0 + B1  (in_tumor)*\nWhen you do this, you’re omitting an important term for contamination:\nE(observed KRT9 expression) = B0 + B1  (in_tumor) + (N_contaminating_transcripts)*\nYour model is underspecified, so its results are biased. As you measure more cells and gain statistical power, you only gain more confidence in your biased results."
  },
  {
    "objectID": "posts/segmentation-error/index.html#countermeasures",
    "href": "posts/segmentation-error/index.html#countermeasures",
    "title": "The impact of segmentation error on differential expression analyses",
    "section": "",
    "text": "We are preparing a manuscript detailing countermeasures to segmentation. Stay tuned for a link to it, or ask us for code if you can’t wait. For now, two pieces of advice:\n\nDon’t bother analyzing genes that are dominated by contamination. If you’re analyzing T-cells in tumors, then analyzing KRT9 is hopeless: T-cells barely express it, while the surrounding tumor cells will express it highly. Whatever expression you do see in T-cells will be dominated by contamination. A simple approach: if you’re e.g. analyzing T-cells, then compare each gene’s expression within T-cells to its expression in spatial neighbors of T-cells. The ratio between these numbers tells you how much of that gene’s expression in T-cells is real vs. contamination. Apply a reasonable threshold, and don’t even analyze genes with much higher expression around T-cells than inside T-cells.\nEstimate each cell’s contamination, and adjust for it in your models. Adding e.g. a term holding a gene’s expression in each cell’s neighbors achieves this well; more complex transformations of this term can be more optimal (see our upcoming paper). However, this only ameliorates, not solves, the bias from contamination. Because your estimated contamination term is a noisy approximation to true contamination, your models will estimate an attenuated effect size for the contamination term, and it won’t remove all the bias."
  },
  {
    "objectID": "link-to-code.html",
    "href": "link-to-code.html",
    "title": "Blog",
    "section": "",
    "text": "Code for this repository is publicly available on github."
  },
  {
    "objectID": "link-to-code.html#code",
    "href": "link-to-code.html#code",
    "title": "Blog",
    "section": "",
    "text": "Code for this repository is publicly available on github."
  }
]